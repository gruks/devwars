---
phase: 01-foundation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/server.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "MongoDB connection established before HTTP server starts accepting requests"
    - "Redis connection established before HTTP server starts accepting requests"
    - "Server waits for all database connections before calling app.listen()"
    - "Graceful shutdown handlers disconnect from MongoDB and Redis"
  artifacts:
    - path: "backend/src/server.js"
      provides: "Async server startup with database connections"
      contains: ["import connectDB", "import connectRedis", "await connectDB()", "await connectRedis()", "async function startServer()"]
      exports: []
  key_links:
    - from: "backend/src/server.js"
      to: "backend/src/config/db.js"
      via: "import and call connectDB()"
      pattern: "import.*connectDB.*from.*config/db|await connectDB\(\)"
    - from: "backend/src/server.js"
      to: "backend/src/config/redis.js"
      via: "import and call connectRedis()"
      pattern: "import.*connectRedis.*from.*config/redis|await connectRedis\(\)"
    - from: "backend/src/server.js"
      to: "backend/src/config/db.js"
      via: "disconnectDB() in shutdown handlers"
      pattern: "await disconnectDB\(\)"
    - from: "backend/src/server.js"
      to: "backend/src/config/redis.js"
      via: "disconnectRedis() in shutdown handlers"
      pattern: "await disconnectRedis\(\)"
---

<objective>
Wire database connections into the server lifecycle by refactoring backend/src/server.js to establish MongoDB and Redis connections before starting the HTTP server, and properly disconnect during graceful shutdown.

Purpose: The database modules exist but are not integrated into server startup. This gap prevents the application from functioning correctly as the server accepts requests before the data layer is ready.
Output: A server.js that properly initializes databases before HTTP startup with robust error handling and graceful shutdown.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/HP/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Gap sources - these are the verification failures being fixed
Gaps to close (from VERIFICATION.md):
1. MongoDB connection not established - server.js missing connectDB() import and call
2. Redis connection not established - server.js missing connectRedis() import and call  
3. Server doesn't wait for databases - synchronous startup needs async refactor

# Existing database modules (from 01-02 plan)
backend/src/config/db.js exports:
- connectDB() - async MongoDB connection
- disconnectDB() - async MongoDB disconnection
- mongoose - mongoose instance

backend/src/config/redis.js exports:
- redisClient - Redis client instance
- connectRedis() - async Redis connection
- disconnectRedis() - async Redis disconnection
- getRedisHealth() - health check function

# Target server.js pattern (from 01-02 SUMMARY key-decisions)
- "Server waits for all database connections before starting HTTP listener"
- "Graceful shutdown closes HTTP server first, then database connections"
- Async startServer() waits for MongoDB and Redis before starting HTTP
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire database connections into server lifecycle</name>
  <files>backend/src/server.js</files>
  <action>
    Read the current backend/src/server.js file to understand its structure, then refactor it to properly integrate database connections:

    1. **Add imports at the top** (after existing imports):
       ```javascript
       import { connectDB, disconnectDB } from './config/db.js';
       import { connectRedis, disconnectRedis } from './config/redis.js';
       ```

    2. **Create async startServer() function** that wraps the current synchronous startup:
       ```javascript
       async function startServer() {
         try {
           // Connect to MongoDB first
           await connectDB();
           logger.info('MongoDB connection established');
           
           // Connect to Redis
           await connectRedis();
           logger.info('Redis connection established');
           
           // Start HTTP server only after both databases are connected
           server = app.listen(PORT, () => {
             logger.info(`Server running on port ${PORT} in ${process.env.NODE_ENV || 'development'} mode`);
           });
         } catch (error) {
           logger.error('Failed to start server:', error.message);
           process.exit(1);
         }
       }
       ```

    3. **Update graceful shutdown handlers** (SIGTERM, SIGINT, SIGHUP) to disconnect databases:
       ```javascript
       // Inside each shutdown handler, after server.close():
       await disconnectDB();
       logger.info('MongoDB connection closed');
       await disconnectRedis();
       logger.info('Redis connection closed');
       ```

    4. **Replace synchronous startup** at the bottom of the file:
       - Remove: `app.listen(PORT, () => { ... });`
       - Add: `startServer();`

    5. **Add error handling** for unhandled promise rejections during startup:
       ```javascript
       process.on('unhandledRejection', (err) => {
         logger.error('Unhandled Rejection:', err.message);
         process.exit(1);
       });
       ```

    Key implementation notes:
    - Maintain the existing logger import and usage patterns
    - Keep the existing graceful shutdown logic, just add database disconnect calls
    - Preserve all existing server configuration (PORT, environment detection, etc.)
    - The server variable must be accessible in the shutdown handlers for server.close()
    - Ensure proper async/await throughout - no callbacks
  </action>
  <verify>
    Verify the implementation by checking that:
    1. File contains both import statements for db.js and redis.js
    2. File contains await connectDB() call before app.listen()
    3. File contains await connectRedis() call before app.listen()
    4. File contains async function startServer() that wraps the startup logic
    5. Shutdown handlers contain await disconnectDB() and await disconnectRedis()
    6. No synchronous app.listen() calls remain at module level
    
    Use grep to verify each pattern exists:
    - grep "import.*connectDB.*from.*config/db" backend/src/server.js
    - grep "import.*connectRedis.*from.*config/redis" backend/src/server.js
    - grep "await connectDB()" backend/src/server.js
    - grep "await connectRedis()" backend/src/server.js
    - grep "async function startServer" backend/src/server.js
    - grep "await disconnectDB()" backend/src/server.js
    - grep "await disconnectRedis()" backend/src/server.js
  </verify>
  <done>
    server.js imports and calls connectDB() and connectRedis() before starting HTTP server, has async startServer() function, and disconnects from both databases during graceful shutdown. All 3 gaps from VERIFICATION.md are closed.
  </done>
</task>

</tasks>

<verification>
All gaps from VERIFICATION.md must be closed:
- [ ] Gap 1 CLOSED: server.js imports connectDB from './config/db.js' and calls await connectDB()
- [ ] Gap 2 CLOSED: server.js imports connectRedis from './config/redis.js' and calls await connectRedis()
- [ ] Gap 3 CLOSED: server.js has async startServer() function that awaits database connections before calling app.listen()
- [ ] Graceful shutdown includes await disconnectDB() and await disconnectRedis() calls
- [ ] Server startup logs show database connections established before "Server running" message
</verification>

<success_criteria>
1. MongoDB connection is established before HTTP server accepts requests
2. Redis connection is established before HTTP server accepts requests  
3. Server startup sequence is: connectDB() -> connectRedis() -> app.listen()
4. Graceful shutdown sequence is: server.close() -> disconnectDB() -> disconnectRedis() -> process.exit()
5. All database connection failures during startup cause process.exit(1) with error logging
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md` documenting:
- What gaps were closed
- Changes made to server.js
- Verification that all 3 truths now pass
</output>
