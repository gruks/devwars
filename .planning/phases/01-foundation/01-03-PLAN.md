---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
  - 01-02
files_modified:
  - backend/src/modules/users/user.model.js
  - backend/src/modules/auth/auth.service.js
  - backend/src/modules/auth/auth.controller.js
  - backend/src/modules/auth/auth.routes.js
  - backend/src/modules/auth/auth.middleware.js
  - backend/src/middlewares/auth.js
  - backend/src/routes.js
autonomous: true

must_haves:
  truths:
    - Users can register with email/password
    - Users can login and receive JWT tokens
    - Authenticated routes validate JWT tokens
    - Passwords are hashed with bcrypt
    - Token refresh mechanism works
    - User model has required fields and validation
  artifacts:
    - path: "backend/src/modules/users/user.model.js"
      provides: "User Mongoose model"
      exports: ["User"]
      contains: ["Schema", "pre('save') hash", "comparePassword method"]
    - path: "backend/src/modules/auth/auth.service.js"
      provides: "Auth business logic"
      exports: ["register", "login", "refreshToken", "logout"]
    - path: "backend/src/modules/auth/auth.controller.js"
      provides: "Auth HTTP handlers"
      exports: ["register", "login", "refreshToken", "logout", "getMe"]
    - path: "backend/src/modules/auth/auth.routes.js"
      provides: "Auth route definitions"
      contains: ["POST /register", "POST /login", "POST /refresh"]
    - path: "backend/src/modules/auth/auth.middleware.js"
      provides: "JWT verification middleware"
      exports: ["authenticate", "authorize"]
    - path: "backend/src/routes.js"
      provides: "Updated route loader with auth routes"
      contains: ["/auth", "authRoutes"]
  key_links:
    - from: "backend/src/modules/auth/auth.service.js"
      to: "backend/src/modules/users/user.model.js"
      via: "User.findOne, User.create"
    - from: "backend/src/modules/auth/auth.controller.js"
      to: "backend/src/modules/auth/auth.service.js"
      via: "authService.login, authService.register"
    - from: "backend/src/modules/auth/auth.routes.js"
      to: "backend/src/modules/auth/auth.controller.js"
      via: "authController.register"
    - from: "backend/src/modules/auth/auth.middleware.js"
      to: "backend/src/config/env.js"
      via: "JWT_SECRET for verification"
---

<objective>
Implement JWT-based authentication system with registration, login, token refresh, and protected routes.

Purpose: Authentication is required for all user-specific features (lobby, rooms, matches, profiles).
Output: Working auth system with User model, auth service, protected routes middleware.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

Database connections are ready. Need to install: bcryptjs, jsonwebtoken
</context>

<tasks>

<task type="auto">
  <name>Install auth dependencies</name>
  <files>
    - backend/package.json
  </files>
  <action>
    Install bcryptjs for password hashing (pure JS, no native deps)
    Install jsonwebtoken for JWT generation and verification
    
    bcryptjs chosen over bcrypt because:
    - No native dependencies (easier deployment)
    - Slightly slower but acceptable for auth
    - Same API as bcrypt
  </action>
  <verify>Run `npm list bcryptjs jsonwebtoken` - both packages installed</verify>
  <done>Auth dependencies installed</done>
</task>

<task type="auto">
  <name>Create User model with password hashing</name>
  <files>
    - backend/src/modules/users/user.model.js
  </files>
  <action>
    Create User Mongoose model:
    
    Schema fields:
    - username: String, required, unique, min 3, max 30
    - email: String, required, unique, lowercase
    - password: String, required, min 6, select: false
    - avatar: String (optional, URL)
    - role: String, enum ['user', 'admin'], default 'user'
    - stats: Object with wins, losses, matchesPlayed, rating
    - refreshTokens: Array of strings (for token rotation)
    - isActive: Boolean, default true
    - timestamps: true (createdAt, updatedAt)
    
    Methods:
    - comparePassword(candidatePassword): returns boolean
    - toJSON(): override to remove password field
    
    Pre-save hook:
    - Hash password with bcryptjs (salt rounds 12) before saving
    - Only hash if password is modified
    
    Indexes:
    - email: unique index
    - username: unique index
  </action>
  <verify>Run `node -e "const User = require('./src/modules/users/user.model.js'); console.log(User.schema.paths)"` - outputs schema paths</verify>
  <done>User model created with password hashing and comparison methods</done>
</task>

<task type="auto">
  <name>Create auth service layer</name>
  <files>
    - backend/src/modules/auth/auth.service.js
  </files>
  <action>
    Create auth service with business logic:
    
    Import: User model, jwt, env, AppError
    
    Functions:
    
    1. register({ username, email, password }):
       - Check if email exists, throw 409 if yes
       - Check if username exists, throw 409 if yes
       - Create user with hashed password
       - Generate tokens (access + refresh)
       - Save refresh token to user
       - Return { user: user.toJSON(), tokens }
    
    2. login({ email, password }):
       - Find user by email with password field
       - If not found, throw 401
       - Compare passwords, throw 401 if no match
       - If user inactive, throw 403
       - Generate tokens
       - Save refresh token
       - Return { user: user.toJSON(), tokens }
    
    3. refreshToken(refreshToken):
       - Verify refresh token with JWT
       - Find user by id from token
       - Check if token is in user's refreshTokens array
       - Remove old token from array (rotation)
       - Generate new tokens
       - Save new refresh token
       - Return { tokens }
    
    4. logout(userId, refreshToken):
       - Find user by id
       - Remove refreshToken from user's refreshTokens array
       - Return success
    
    Token generation helper:
    - generateTokens(userId): returns { accessToken, refreshToken }
    - accessToken: expires in JWT_EXPIRES_IN (15m)
    - refreshToken: expires in 7 days
  </action>
  <verify>Import service in test, verify all functions exported and use User model correctly</verify>
  <done>Auth service implements register, login, refresh, logout with proper token handling</done>
</task>

<task type="auto">
  <name>Create auth controller</name>
  <files>
    - backend/src/modules/auth/auth.controller.js
  </files>
  <action>
    Create auth controller with HTTP handlers:
    
    Import: authService, asyncHandler, logger
    
    Handlers (all wrapped with asyncHandler):
    
    1. register(req, res):
       - Extract username, email, password from body
       - Validate required fields
       - Call authService.register
       - Return 201 with { success: true, data: { user, tokens } }
    
    2. login(req, res):
       - Extract email, password from body
       - Validate required fields
       - Call authService.login
       - Return 200 with { success: true, data: { user, tokens } }
    
    3. refreshToken(req, res):
       - Extract refreshToken from body
       - Call authService.refreshToken
       - Return 200 with { success: true, data: { tokens } }
    
    4. logout(req, res):
       - Get userId from req.user (set by auth middleware)
       - Extract refreshToken from body
       - Call authService.logout
       - Return 200 with { success: true, message: 'Logged out' }
    
    5. getMe(req, res):
       - Get user from req.user
       - Return 200 with { success: true, data: { user } }
  </action>
  <verify>Import controller, verify all handlers exported and call correct service methods</verify>
  <done>Auth controller with all 5 handlers created</done>
</task>

<task type="auto">
  <name>Create auth routes</name>
  <files>
    - backend/src/modules/auth/auth.routes.js
  </files>
  <action>
    Create auth routes:
    
    Import: express Router, authController, authenticate middleware
    
    Routes:
    - POST /register -> authController.register
    - POST /login -> authController.login
    - POST /refresh -> authController.refreshToken
    - POST /logout -> authenticate, authController.logout
    - GET /me -> authenticate, authController.getMe
    
    Export router
  </action>
  <verify>Import routes, verify all 5 routes defined correctly</verify>
  <done>Auth routes mounted with proper middleware</done>
</task>

<task type="auto">
  <name>Create authentication middleware</name>
  <files>
    - backend/src/modules/auth/auth.middleware.js
    - backend/src/middlewares/auth.js
  </files>
  <action>
    Create authentication middleware:
    
    In auth.middleware.js:
    
    1. authenticate(req, res, next):
       - Extract Authorization header
       - Check format "Bearer <token>", throw 401 if invalid format
       - Verify JWT using JWT_SECRET
       - If invalid/expired, throw 401
       - Find user by id from token payload
       - If user not found or inactive, throw 401
       - Attach user to req.user
       - Call next()
    
    2. authorize(...roles):
       - Returns middleware function
       - Check if req.user.role is in allowed roles
       - If not, throw 403 "Insufficient permissions"
       - Call next()
    
    Also create backend/src/middlewares/auth.js that re-exports from auth.middleware.js for cleaner imports
  </action>
  <verify>Import middleware, verify authenticate and authorize functions work correctly</verify>
  <done>Auth middleware validates JWT and attaches user to requests, authorize checks roles</done>
</task>

<task type="auto">
  <name>Mount auth routes and test endpoints</name>
  <files>
    - backend/src/routes.js
  </files>
  <action>
    Update backend/src/routes.js:
    
    - Import authRoutes from modules/auth/auth.routes
    - Mount authRoutes at /auth
    - Keep health check at root
    
    Test all endpoints work:
    1. POST /api/v1/auth/register - create test user
    2. POST /api/v1/auth/login - login with credentials
    3. GET /api/v1/auth/me - with Bearer token from login
    4. POST /api/v1/auth/refresh - with refresh token
    5. POST /api/v1/auth/logout - with Bearer token
    
    Use curl commands in verify step
  </action>
  <verify>
    curl -X POST http://localhost:3000/api/v1/auth/register -H "Content-Type: application/json" -d '{"username":"test","email":"test@test.com","password":"password123"}'
    curl -X POST http://localhost:3000/api/v1/auth/login -H "Content-Type: application/json" -d '{"email":"test@test.com","password":"password123"}'
    All endpoints return expected responses
  </verify>
  <done>Auth routes mounted, all endpoints tested and working</done>
</task>

</tasks>

<verification>
1. POST /api/v1/auth/register creates user and returns tokens
2. POST /api/v1/auth/login returns tokens for valid credentials
3. GET /api/v1/auth/me returns user data with valid JWT
4. POST /api/v1/auth/refresh returns new access token
5. POST /api/v1/auth/logout invalidates refresh token
6. Passwords are hashed in database (not stored plain)
7. Invalid credentials return 401
</verification>

<success_criteria>
- Registration creates user with hashed password
- Login returns valid JWT access and refresh tokens
- Protected routes require valid JWT
- Token refresh generates new access token
- Logout invalidates refresh token
- Auth middleware attaches user to requests
- All auth endpoints follow REST conventions
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
