---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - backend/.env
  - backend/.env.example
  - backend/src/config/env.js
  - backend/src/utils/logger.js
  - backend/src/utils/constants.js
  - backend/src/app.js
  - backend/src/server.js
  - backend/src/middlewares/error.js
  - backend/src/routes.js
autonomous: true

must_haves:
  truths:
    - Environment variables load correctly from .env
    - Logger outputs formatted logs with timestamps
    - Centralized error handling catches all errors
    - App separates Express setup from server startup
    - Route loader aggregates all module routes
  artifacts:
    - path: "backend/package.json"
      provides: "Project dependencies and scripts"
      contains: ["dependencies", "devDependencies", "scripts"]
    - path: "backend/.env"
      provides: "Environment configuration"
      contains: ["PORT", "NODE_ENV", "MONGODB_URI"]
    - path: "backend/src/config/env.js"
      provides: "Environment variable loader with validation"
      exports: ["env", "validateEnv"]
    - path: "backend/src/utils/logger.js"
      provides: "Winston logger instance"
      exports: ["logger"]
    - path: "backend/src/middlewares/error.js"
      provides: "Global error handler middleware"
      exports: ["errorHandler"]
    - path: "backend/src/app.js"
      provides: "Express app configuration"
      exports: ["app"]
    - path: "backend/src/server.js"
      provides: "Server entry point"
      contains: ["server.listen"]
  key_links:
    - from: "backend/src/server.js"
      to: "backend/src/app.js"
      via: "import"
    - from: "backend/src/app.js"
      to: "backend/src/middlewares/error.js"
      via: "app.use(errorHandler)"
    - from: "backend/src/config/env.js"
      to: "backend/.env"
      via: "dotenv.config"
---

<objective>
Set up the foundation infrastructure for the DevWars backend including environment configuration, logging, error handling, and project structure.

Purpose: Establish the core infrastructure patterns that all future modules will build upon.
Output: A running Express server with proper configuration, logging, and error handling.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Current app.js has basic Express setup. We'll restructure to production patterns.
</context>

<tasks>

<task type="auto">
  <name>Install dependencies and update package.json</name>
  <files>
    - backend/package.json
  </files>
  <action>
    Install production dependencies: dotenv, cors, helmet, morgan, winston
    Install dev dependencies: nodemon
    Add scripts: "dev": "nodemon src/server.js", "start": "node src/server.js"
    Update main entry to "src/server.js"
    Keep existing express dependency
  </action>
  <verify>Run `npm list dotenv cors helmet morgan winston nodemon` - all packages installed</verify>
  <done>package.json updated with all dependencies and proper scripts</done>
</task>

<task type="auto">
  <name>Create environment configuration</name>
  <files>
    - backend/.env
    - backend/.env.example
    - backend/src/config/env.js
  </files>
  <action>
    Create backend/src/config/env.js that:
    - Loads .env via dotenv
    - Exports validated env object with defaults
    - Required vars: PORT (default 3000), NODE_ENV (default development)
    - Optional vars: MONGODB_URI, REDIS_URL, JWT_SECRET, JWT_REFRESH_SECRET, JWT_EXPIRES_IN
    - Validate required vars exist, throw clear error if missing
    
    Create backend/.env with development defaults:
    PORT=3000
    NODE_ENV=development
    MONGODB_URI=mongodb://localhost:27017/devwars
    REDIS_URL=redis://localhost:6379
    JWT_SECRET=dev-jwt-secret-change-in-production
    JWT_REFRESH_SECRET=dev-refresh-secret-change-in-production
    JWT_EXPIRES_IN=15m
    
    Create backend/.env.example as template (without values)
  </action>
  <verify>Run `node -e "const env = require('./src/config/env.js'); console.log(env.PORT)"` - outputs 3000</verify>
  <done>Environment config loads correctly, validation works, .env and .env.example created</done>
</task>

<task type="auto">
  <name>Create utilities and constants</name>
  <files>
    - backend/src/utils/logger.js
    - backend/src/utils/constants.js
    - backend/src/utils/helpers.js
  </files>
  <action>
    Create logger.js using winston:
    - Console transport with colorized output
    - Include timestamp in ISO format
    - Log level from env (default info)
    - Export logger instance
    
    Create constants.js with:
    - HTTP status codes object
    - Error messages object
    - Socket event names (LOBBY_JOIN, ROOM_CREATE, etc.)
    - Game constants (MAX_PLAYERS, ROUND_TIME, etc.)
    
    Create helpers.js with:
    - asyncHandler wrapper for Express routes
    - Response formatter function
  </action>
  <verify>Run `node -e "const logger = require('./src/utils/logger.js'); logger.info('test')"` - outputs formatted log</verify>
  <done>Logger works, constants defined, helpers exported</done>
</task>

<task type="auto">
  <name>Create error handling middleware</name>
  <files>
    - backend/src/middlewares/error.js
  </files>
  <action>
    Create error handling middleware that:
    - Catches all errors in Express pipeline
    - Logs errors with stack trace in development
    - Returns JSON response with { success: false, message, ...(dev && stack) }
    - Handles specific error types (ValidationError, CastError, JWT errors)
    - Default 500 status for unknown errors
    
    Create custom AppError class extending Error with statusCode and isOperational flags
  </action>
  <verify>Import middleware in test script, verify it exports errorHandler and AppError</verify>
  <done>Error middleware handles errors, AppError class works for operational errors</done>
</task>

<task type="auto">
  <name>Restructure app and server files</name>
  <files>
    - backend/src/app.js
    - backend/src/server.js
    - backend/src/routes.js
  </files>
  <action>
    Update backend/src/app.js:
    - Import express, cors, helmet, morgan
    - Import env config (triggers dotenv load)
    - Import errorHandler
    - Setup middleware: helmet, cors, express.json(), morgan
    - Import and mount routes from routes.js at /api/v1
    - Mount errorHandler last
    - Export app (don't start server here)
    
    Create backend/src/server.js:
    - Import app from app.js
    - Import logger
    - Get PORT from env
    - Start server with app.listen
    - Log "Server running on port X"
    - Handle unhandled promise rejections and uncaught exceptions
    
    Create backend/src/routes.js:
    - Import express Router
    - Create router
    - Add health check route GET /health returning { status: 'ok', timestamp }
    - Export router for mounting in app.js
  </action>
  <verify>Run `npm run dev`, curl http://localhost:3000/api/v1/health - returns { status: 'ok' }</verify>
  <done>Server starts, health endpoint works, logs show formatted output, error handling active</done>
</task>

</tasks>

<verification>
1. Server starts with `npm run dev`
2. Health endpoint returns 200 with status: ok
3. Logs show timestamps and colorized output
4. Environment variables load from .env
5. Error middleware catches thrown errors
</verification>

<success_criteria>
- Server runs on configured port
- All new dependencies installed
- Environment config validates variables
- Logger outputs formatted logs
- Error handling middleware catches errors
- Health endpoint responds correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
