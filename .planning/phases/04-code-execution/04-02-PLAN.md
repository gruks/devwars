---
phase: 04-code-execution
plan: '02'
type: execute
wave: 1
depends_on: [04-01]
files_modified:
  - backend/src/services/execution.service.js
  - compilers/sandbox-service
  - docker-compose.yml (if needed)
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Backend execution.service.js can communicate with sandbox-service"
    - "Sandbox-service handles multiple languages (python, javascript, java, go, cpp)"
    - "Error handling works (timeout, syntax errors, runtime errors)"
    - "Health check endpoint confirms service is running"
  artifacts:
    - path: "compilers/sandbox-service"
      provides: "Running code execution service"
      status: "operational"
    - path: "backend/src/services/execution.service.js"
      provides: "Backend wrapper for sandbox API"
      calls: "sandbox-service /api/execute"
  key_links:
    - from: "execution.service.js"
      to: "sandbox-service"
      via: "axios.post to SANDBOX_SERVICE_URL"
      pattern: "localhost:3000.*execute"
---

<objective>
Ensure the backend can successfully communicate with the sandbox-service and handle all execution scenarios. Add Docker Compose for easy service orchestration.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/HP/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-code-execution/04-01-PLAN.md

## Context

After Plan 04-01, the sandbox-service should be operational. This plan ensures:
1. Backend integration works
2. All supported languages can execute
3. Error handling is robust
4. Services can be easily started together

**Backend already has**:
- execution.service.js that calls sandbox-service ✓
- Proper error handling for connection issues ✓
- Language mapping ✓
</context>

<tasks>

<task type="auto">
<name>Task 1: Test backend to sandbox integration</name>
<parameter name="files">backend/src/services/execution.service.js</files>
  <action>
    Verify the backend execution service works with sandbox-service:
    1. Ensure sandbox-service is running (start if not)
    2. Test executeCode with simple JavaScript: `console.log(1+1)`
    3. Test with Python: `print(1+1)`
    4. Verify results are returned correctly
    5. Test error handling (invalid syntax, timeout)

    The execution.service.js already exists, just verify it works
  </action>
  <verify>
    - JavaScript execution returns "2"
    - Python execution returns "2"
    - Invalid code returns error in stderr
    - Connection refused returns friendly error
  </verify>
  <done>
    Backend execution service successfully calls sandbox-service and returns results.
  </done>
</task>

<task type="auto">
<name>Task 2: Add Docker Compose for service orchestration</name>
  <files>compilers/docker-compose.yml</files>
  <action>
    Create docker-compose.yml to run all required services:
    1. Redis service (for BullMQ queue)
    2. Sandbox API service
    3. Sandbox Worker service
    4. Volume for Docker socket access

    This makes it easy to start all services with one command
  </action>
  <verify>
    - docker-compose up starts all services
    - Services can communicate with each other
    - Logs show services are healthy
  </verify>
  <done>
    Docker Compose file enables starting all code execution services with one command.
  </done>
</task>

<task type="auto">
<name>Task 3: Test multi-language execution</name>
  <files>compilers/sandbox-service</files>
  <action>
    Verify all supported languages work:
    1. JavaScript: `console.log("test")`
    2. Python: `print("test")`
    3. Java: simple Hello World
    4. Go: simple Hello World
    5. C++: simple Hello World

    Note: Some may need Docker images pulled first
  </action>
  <verify>
    - Each language executes without errors
    - Output matches expected result
    - Errors are properly captured in stderr
  </verify>
  <done>
    All supported languages can execute code through the sandbox-service.
  </done>
</task>

</tasks>

<verification>
- [ ] Backend execution service integrates with sandbox
- [ ] Docker Compose runs all services
- [ ] All 5 languages execute successfully
- [ ] Error handling works for edge cases
</verification>

<success_criteria>
Backend can execute code in all supported languages through the sandbox-service. Services are easily started via Docker Compose.
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-execution/04-02-SUMMARY.md`
</output>
