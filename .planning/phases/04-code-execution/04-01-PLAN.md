---
phase: 04-code-execution
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - compilers/sandbox-service/src/queue/queue.js
  - compilers/sandbox-service/package.json
  - compilers/sandbox-service/src/workers/executor.js
  - compilers/sandbox-service/src/api/routes.js
autonomous: true
user_setup:
  - service: redis
    why: "Required for BullMQ queue"
    env_vars:
      - name: REDIS_HOST
        source: "Environment variable or localhost"
    dashboard_config: []

must_haves:
  truths:
    - "Sandbox-service can start and connect to Redis"
    - "BullMQ queue is created and worker can process jobs"
    - "Execution API accepts code and returns results"
    - "Docker runner executes code in isolated containers"
    - "Security constraints applied (memory, CPU, network disabled)"
  artifacts:
    - path: "compilers/sandbox-service/src/queue/queue.js"
      provides: "BullMQ queue with Redis connection"
      min_lines: 30
    - path: "compilers/sandbox-service/package.json"
      provides: "Start scripts for API server and worker"
      scripts: ["start:api", "start:worker", "start:all"]
  key_links:
    - from: "routes.js"
      to: "queue.js"
      via: "executionQueue.add()"
      pattern: "executionQueue\\.add"
    - from: "executor.js"
      to: "queue.js"
      via: "Worker import"
      pattern: "import.*connection.*queue"
---

<objective>
Fix and complete the sandbox-service to make it runnable. The queue.js is empty, preventing the worker from starting. Complete the BullMQ queue setup and add start scripts.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/HP/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md

## Gap Analysis

**Problem**: compilers/sandbox-service/src/queue/queue.js is empty (1 line), causing the worker to fail on import.

**What's done**:
- Docker runner with security constraints ✓ (compilers/sandbox-service/src/docker/runner.js)
- Worker code exists ✓ (executor.js imports from queue.js)
- API routes exist ✓ (routes.js)
- Security limits defined ✓ (security/limits.js)

**What's missing**:
- queue.js is empty - no Redis connection or BullMQ queue exported
- No start scripts in package.json for running API and worker separately
- executor.js imports from queue.js but gets nothing

**Phase 4 delivers**:
- Docker execution environment
- BullMQ queue setup
- Code execution worker
- Security constraints (no network, timeouts, memory limits)
- Execution results handling
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement BullMQ queue in queue.js</name>
  <files>compilers/sandbox-service/src/queue/queue.js</files>
  <action>
    Complete the BullMQ queue implementation:
    1. Import Bull and Redis from ioredis
    2. Create Redis connection configuration (host, port from env)
    3. Create executionQueue using BullMQ
    4. Export both connection and executionQueue
    5. Handle connection errors and reconnection

    Reference: executor.js imports { connection, executionQueue } from './queue.js'
  </action>
  <verify>
    - queue.js exports connection and executionQueue
    - No syntax errors when importing in executor.js
    - Redis connection can be established
  </verify>
  <done>
    queue.js exports working Redis connection and BullMQ queue. Worker can import and use them.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add start scripts to package.json</name>
  <files>compilers/sandbox-service/package.json</files>
  <action>
    Add npm scripts to run the sandbox-service:
    1. "start:api" - runs the Fastify server (server.js)
    2. "start:worker" - runs the executor worker (executor.js)
    3. "start:all" - runs both in parallel (concurrently or &)
    4. Ensure all dependencies are in package.json (fastify, bullmq, ioredis, dockerode, etc.)

    Use nodemon for development, node for production
  </action>
  <verify>
    - npm run start:api starts the API server
    - npm run start:worker starts the worker
    - Both can run simultaneously
  </verify>
  <done>
    package.json has scripts to start API server and worker independently or together.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix API routes to use queue</name>
  <files>compilers/sandbox-service/src/api/routes.js</files>
  <action>
    Ensure the API route properly adds jobs to the queue:
    1. Import executionQueue from '../queue/queue.js'
    2. When POST /execute is called, add job to queue
    3. Wait for job result using job.waitUntilFinished()
    4. Return execution result to client

    The route already has the structure, just needs queue import and job handling
  </action>
  <verify>
    - POST /api/execute adds job to queue
    - Job is processed by worker
    - Result is returned to client
  </verify>
  <done>
    API endpoint creates queue jobs and returns execution results.
  </done>
</task>

<task type="auto">
  <name>Task 4: Test end-to-end execution flow</name>
  <files>compilers/sandbox-service</files>
  <action>
    Verify the complete execution flow:
    1. Start Redis (if not running)
    2. Run npm run start:all (or start both api and worker)
    3. Test POST /api/execute with sample code
    4. Verify execution result is returned

    Sample test:
    ```json
    {
      "language": "javascript",
      "code": "console.log('Hello from sandbox')",
      "timeout": 2000
    }
    ```
  </action>
  <verify>
    - API server starts on port 3000
    - Worker connects to Redis and listens for jobs
    - POST /api/execute returns execution result
  </verify>
  <done>
    Complete execution flow working: API → Queue → Worker → Docker → Result → API Response
  </done>
</task>

</tasks>

<verification>
- [ ] queue.js exports connection and executionQueue
- [ ] package.json has start scripts
- [ ] API adds jobs to queue
- [ ] Worker processes jobs
- [ ] End-to-end execution works
</verification>

<success_criteria>
Sandbox-service can start, accept code execution requests, process them through BullMQ queue, execute in Docker, and return results.
</success_criteria>

<output>
After completion, create `.planning/phases/04-code-execution/04-01-SUMMARY.md`
</output>
