---
phase: 03-game-engine
plan: "04"
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - backend/src/socket/handlers/game.handler.js
  backend/src/modules/rooms/room.controller.js
autonomous: true

must_haves:
  truths:
    - "Players receive MATCH_START event when match begins"
    - "Code updates are broadcast to all players"
    - "Player solved event is broadcast"
    - "Match end event includes final results"
    - "Timer is synchronized across all players"
  artifacts:
    - path: "backend/src/socket/handlers/game.handler.js"
      provides: "Game socket event handlers"
      exports: ["registerGameHandlers"]
    - path: "Socket events"
      provides: "Real-time game communication"
      events: ["MATCH_START", "CODE_UPDATE", "CODE_SUBMIT", "PLAYER_SOLVED", "MATCH_END", "TIMER_SYNC"]
  key_links:
    - from: "game.handler.js"
      to: "match.service.js"
      via: "Function calls"
      pattern: "matchService\\."
    - from: "game.handler.js"
      to: "room.model.js"
      via: "Room updates"
      pattern: "Room\\."
    - from: "game.handler.js"
      to: "io (Socket.io)"
      via: "Broadcast events"
      pattern: "io\\.to\\(roomId\\)"
---

<objective>
Create game socket event handlers for real-time battle communication.

Purpose: Enable real-time communication for match events including start, code updates, submissions, and results.
Output: Socket handlers for MATCH_START, CODE_UPDATE, CODE_SUBMIT, PLAYER_SOLVED, MATCH_END, TIMER_SYNC
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/HP/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-game-engine/03-CONTEXT.md
@.planning/phases/03-game-engine/03-03-SUMMARY.md
@backend/src/modules/rooms/room.model.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Game Socket Handler</name>
  <files>backend/src/socket/handlers/game.handler.js</files>
  <action>
Create game.handler.js in backend/src/socket/handlers/:
- Function registerGameHandlers(io, socket):
  - Middleware: authenticate socket using existing socketAuth middleware
  - Join roomId namespace on join_room event
  
  - Event 'match:start' (data: { roomId, questionId, timerDuration }):
    - Validate user is host of room
    - Call matchService.createMatch and startMatch
    - Get question from Question model (select starterCode, testcases)
    - Broadcast to room: { type: 'MATCH_START', data: { question: { title, description, starterCode, testcases: [{input, output}] }, timerEndTime } }
    - Store matchId in socket.data for this room
    
  - Event 'match:code-update' (data: { roomId, code }):
    - Broadcast to room (excluding sender): { type: 'CODE_UPDATE', data: { playerId, username, code } }
    
  - Event 'match:submit' (data: { roomId, code }):
    - Call matchService.submitCode with playerId from socket.data
    - Broadcast to room: { type: 'PLAYER_SOLVED', data: { playerId, username, score, isFirstBlood } }
    - If all players solved or timer ended, trigger match:end
    
  - Event 'match:end' (data: { roomId }):
    - Call matchService.endMatch
    - Broadcast to room: { type: 'MATCH_END', data: { results: [...], winner, duration } }
    
  - Event 'match:timer-sync' (data: { roomId }):
    - Return current timer state: { type: 'TIMER_SYNC', data: { remainingTime, isPaused } }

- Export { registerGameHandlers }

Create backend/src/socket/handlers/index.js to export all handlers
  </action>
  <verify>Game handler exports registerGameHandlers function; handles all game events</verify>
  <done>Game socket handler processes match lifecycle events in real-time</done>
</task>

<task type="auto">
  <name>Task 2: Integrate with Room Controller</name>
  <files>backend/src/modules/rooms/room.controller.js</files>
  <action>
Update room.controller.js:
- In startMatch controller:
  - After successfully starting match in Room model
  - Emit socket event to room: io.to(roomId).emit('game:match_start', { question, timerDuration })
  - This triggers the frontend to navigate to game view

- Create new endpoint POST /rooms/:id/start-match:
  - Validates room exists, user is host, room status is waiting, min players >= 2
  - Randomly selects a question (mode=debug, difficulty matching room.skillLevel)
  - Returns { success: true, matchId, question: { title, description, starterCode } }
  - The socket handler will broadcast the full question with testcases to players

Note: Keep existing /rooms/:id/start endpoint for simple "ready" flow, add new /start-match for full game
  </action>
  <verify>Room controller has start-match endpoint that initiates game flow</verify>
  <done>Room controller integrated with game flow via socket events</done>
</task>

</tasks>

<verification>
- Game socket handler registered and responding to events
- MATCH_START broadcasts question to all players
- CODE_UPDATE broadcasts code changes
- PLAYER_SOLVED broadcasts when player solves
- MATCH_END broadcasts final results
- Timer synchronization works
</verification>

<success_criteria>
Real-time socket events enable full debug battle gameplay
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-engine/03-04-SUMMARY.md`
</output>
