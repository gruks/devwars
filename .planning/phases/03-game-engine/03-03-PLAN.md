---
phase: 03-game-engine
plan: "03"
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - backend/src/modules/matches/match.model.js
  - backend/src/modules/matches/match.service.js
  - backend/src/modules/matches/match.controller.js
  - backend/src/modules/matches/match.routes.js
  - backend/src/routes.js
autonomous: true

must_haves:
  truths:
    - "Match state can be tracked in database"
    - "Match can be started with question and timer"
    - "Player submissions can be recorded and scored"
    - "Match can end with final results"
  artifacts:
    - path: "backend/src/modules/matches/match.model.js"
      provides: "Match MongoDB schema"
      contains: "model Match"
    - path: "backend/src/modules/matches/match.service.js"
      provides: "Match business logic"
      exports: ["createMatch", "startMatch", "submitCode", "endMatch", "getMatchResults"]
    - path: "backend/src/modules/matches/match.controller.js"
      provides: "Match HTTP handlers"
    - path: "backend/src/modules/matches/match.routes.js"
      provides: "Match API endpoints"
      exports: ["POST /api/v1/matches", "POST /api/v1/matches/:id/start", "POST /api/v1/matches/:id/submit", "POST /api/v1/matches/:id/end"]
  key_links:
    - from: "match.service.js"
      to: "question.model.js"
      via: "Question.findById()"
      pattern: "Question\\.findById"
    - from: "match.service.js"
      to: "evaluation.controller.js"
      via: "evaluateSolution()"
      pattern: "evaluateSolution"
    - from: "match.service.js"
      to: "room.model.js"
      via: "Room.findById()"
      pattern: "Room\\.findById"
---

<objective>
Create Match model and state management for debug battles.

Purpose: Track match state including question, players, submissions, timer, and results.
Output: Match model with service layer and API endpoints
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/HP/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-game-engine/03-CONTEXT.md
@.planning/phases/03-game-engine/03-01-SUMMARY.md
@.planning/phases/03-game-engine/03-02-SUMMARY.md
@backend/src/modules/rooms/room.model.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Match Model</name>
  <files>backend/src/modules/matches/match.model.js</files>
  <action>
Create Match model in backend/src/modules/matches/match.model.js:
- Schema fields:
  - roomId: ObjectId ref Room (required)
  - questionId: ObjectId ref Question (required)
  - status: enum ['waiting', 'active', 'finished'] (default: waiting)
  - startTime: Date
  - endTime: Date
  - duration: Number (seconds)
  - timerDuration: Number (seconds, default 900 = 15 min)
  - submissions: [{
      playerId: ObjectId,
      username: String,
      code: String,
      score: Number,
      solvedAt: Date,
      testResults: [{ passed: Boolean, input, expected, actual }]
    }]
  - players: [{ playerId: ObjectId, username: String, score: Number, solvedAt: Date }]
  - winner: playerId from players array
  - createdAt, updatedAt timestamps
- Indexes: roomId, status, 'submissions.playerId'
- Export { Match }
  </action>
  <verify>Match model created with all fields; exports Match model</verify>
  <done>Match model tracks room, question, players, submissions, timer, and winner</done>
</task>

<task type="auto">
  <name>Task 2: Create Match Service</name>
  <files>backend/src/modules/matches/match.service.js</files>
  <action>
Create match.service.js with functions:
- createMatch({ roomId, questionId, timerDuration }):
  - Validate room exists and status is playing
  - Validate question exists and mode is debug
  - Create match with players from room
  - Return match
- startMatch(matchId):
  - Find match, set status='active', startTime=now
  - Return match
- submitCode(matchId, playerId, code):
  - Find match, must be active
  - Call evaluateSolution with question and code
  - Update player's submission in submissions array
  - If first to solve (score=100), set solvedAt and check for winner
  - Return { score, passedTests, totalTests, isFirstBlood }
- endMatch(matchId):
  - Find match, set status='finished', endTime=now
  - Calculate duration
  - Determine winner (highest score, earliest solve time)
  - Update player stats in User collection (wins/losses/rating)
  - Return final results
- getMatchResults(matchId):
  - Return match with submissions sorted by score desc, then solvedAt asc
- Export all functions
  </action>
  <verify>Service exports createMatch, startMatch, submitCode, endMatch, getMatchResults</verify>
  <done>Match service handles full lifecycle: create, start, submit, end, results</done>
</task>

<task type="auto">
  <name>Task 3: Create Match Routes</name>
  <files>backend/src/modules/matches/match.controller.js, backend/src/modules/matches/match.routes.js, backend/src/routes.js</files>
  <action>
Create match.controller.js:
- createMatch(req): Call service.createMatch, return 201
- startMatch(req): Call service.startMatch
- submitCode(req): Call service.submitCode with playerId from req.user
- endMatch(req): Call service.endMatch
- getMatchResults(req): Call service.getMatchResults

Create match.routes.js:
- POST / - createMatch (protected, host only)
- POST /:id/start - startMatch (protected, host only)
- POST /:id/submit - submitCode (protected)
- POST /:id/end - endMatch (protected, host only)
- GET /:id/results - getMatchResults (protected)

Update backend/src/routes.js:
- router.use('/matches', require('./modules/matches/match.routes.js'));
  </action>
  <verify>Routes registered at /api/v1/matches; all endpoints functional</verify>
  <done>Match API available at /api/v1/matches with full lifecycle endpoints</done>
</task>

</tasks>

<verification>
- Match model tracks all game state
- Service handles full match lifecycle with scoring
- Routes provide REST API for match operations
</verification>

<success_criteria>
Matches can be created, started, have code submitted, and ended with results
</success_criteria>

<output>
After completion, create `.planning/phases/03-game-engine/03-03-SUMMARY.md`
</output>
