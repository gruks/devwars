---
phase: 02-realtime
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/modules/socket/handlers/lobby.js
  - backend/src/modules/socket/handlers/room.js
  - backend/src/modules/socket/middleware/error.js
  - backend/src/modules/socket/index.js
  - backend/src/modules/rooms/room.model.js
  - code-arena/src/contexts/SocketContext.tsx
  - code-arena/src/pages/app/Lobby.tsx
  - code-arena/package.json
autonomous: true
must_haves:
  truths:
    - "Authenticated users can join lobby and receive room list via socket"
    - "Room creation broadcasts new room to all lobby users in real-time"
    - "Room updates (player joins/leaves) broadcast to lobby in real-time"
    - "Frontend SocketContext provides socket instance to all components"
    - "Lobby page uses socket events instead of polling for updates"
  artifacts:
    - path: "backend/src/modules/socket/handlers/lobby.js"
      provides: "Lobby event handlers (lobby:join, lobby:leave)"
      exports: ["registerLobbyHandlers"]
    - path: "backend/src/modules/socket/handlers/room.js"
      provides: "Room event handlers (room:create, room:join, room:leave)"
      exports: ["registerRoomHandlers"]
    - path: "backend/src/modules/socket/middleware/error.js"
      provides: "Error handling wrapper for socket events"
      exports: ["asyncHandler", "socketErrorHandler"]
    - path: "code-arena/src/contexts/SocketContext.tsx"
      provides: "React context for socket connection"
      exports: ["SocketProvider", "useSocket"]
  key_links:
    - from: "backend/src/modules/socket/index.js"
      to: "backend/src/modules/socket/handlers/lobby.js"
      via: "registerLobbyHandlers(io, socket)"
    - from: "backend/src/modules/socket/handlers/room.js"
      to: "backend/src/modules/rooms/room.model.js"
      via: "Room.findById(), room.addPlayer(), room.removePlayer()"
    - from: "code-arena/src/pages/app/Lobby.tsx"
      to: "code-arena/src/contexts/SocketContext.tsx"
      via: "const { socket } = useSocket()"
    - from: "code-arena/src/contexts/SocketContext.tsx"
      to: "socket.io-client"
      via: "io(API_URL, { withCredentials: true })"
---

<objective>
Implement lobby and room socket event handlers with proper error handling, and create frontend SocketContext to replace polling with real-time updates.

Purpose: Enable real-time lobby functionality with live room lists and instant updates when rooms change.
Output: Modular socket handlers for lobby and rooms, error handling wrapper, and frontend SocketContext with Lobby integration.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-realtime/02-RESEARCH.md
@backend/src/config/socket.js
@code-arena/src/pages/app/Lobby.tsx
@code-arena/src/contexts/AuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install socket.io-client and create error handling middleware</name>
  <files>
    code-arena/package.json
    backend/src/modules/socket/middleware/error.js
  </files>
  <action>
Install socket.io-client in frontend:
```bash
cd code-arena && npm install socket.io-client
```

Create `backend/src/modules/socket/middleware/error.js`:

```javascript
/**
 * Socket.io error handling middleware
 * Wraps async handlers to catch errors
 */
const { logger } = require('../../../utils/logger.js');
const { EVENTS } = require('../utils/events.js');

/**
 * Async handler wrapper for socket events
 * Catches errors and sends standardized error response
 */
const asyncHandler = (fn) => {
  return async (socket, ...args) => {
    try {
      await fn(socket, ...args);
    } catch (error) {
      // Get callback function (last argument)
      const callback = args[args.length - 1];
      const hasCallback = typeof callback === 'function';

      // Log error with context
      logger.error('Socket event error:', {
        error: error.message,
        socketId: socket.id,
        userId: socket.user?.userId,
        stack: error.stack
      });

      // Determine error type and message
      let errorMessage = 'Internal server error';
      let statusCode = 500;

      if (error.name === 'ValidationError') {
        errorMessage = 'Invalid data provided';
        statusCode = 400;
      } else if (error.name === 'CastError') {
        errorMessage = 'Invalid ID format';
        statusCode = 400;
      } else if (error.message === 'Authentication required') {
        errorMessage = 'Authentication required';
        statusCode = 401;
      } else if (error.message.includes('not found')) {
        errorMessage = error.message;
        statusCode = 404;
      } else if (process.env.NODE_ENV === 'development') {
        // In development, expose actual error
        errorMessage = error.message;
      }

      // Send error response
      const errorResponse = {
        success: false,
        error: errorMessage,
        code: statusCode,
        timestamp: new Date().toISOString()
      };

      if (hasCallback) {
        callback(errorResponse);
      } else {
        socket.emit(EVENTS.SYSTEM.ERROR, errorResponse);
      }
    }
  };
};

/**
 * Socket error handler middleware
 * Handles errors thrown in other middleware
 */
const socketErrorHandler = (error, socket, next) => {
  logger.error('Socket middleware error:', {
    error: error.message,
    socketId: socket.id
  });

  // Emit error to client
  socket.emit(EVENTS.SYSTEM.ERROR, {
    success: false,
    error: error.message || 'Connection error',
    timestamp: new Date().toISOString()
  });

  next(error);
};

module.exports = { asyncHandler, socketErrorHandler };
```
</action>
  <verify>
```bash
cd code-arena && npm list socket.io-client
cd backend && node -e "const { asyncHandler } = require('./src/modules/socket/middleware/error.js'); console.log('asyncHandler export OK');"
```
  </verify>
  <done>
- socket.io-client installed in code-arena
- backend/src/modules/socket/middleware/error.js created
- asyncHandler wraps socket event handlers with try/catch
- Errors logged and sent to client with standardized format
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lobby event handlers</name>
  <files>
    backend/src/modules/socket/handlers/lobby.js
  </files>
  <action>
Create `backend/src/modules/socket/handlers/lobby.js`:

```javascript
/**
 * Lobby event handlers
 */
const { Room } = require('../../rooms/room.model.js');
const { EVENTS } = require('../utils/events.js');
const { asyncHandler } = require('../middleware/error.js');
const { logger } = require('../../../utils/logger.js');

/**
 * Register lobby event handlers
 * @param {Object} io - Socket.io instance
 * @param {Object} socket - Socket instance
 * @param {Map} connectedUsers - Map of connected users
 */
const registerLobbyHandlers = (io, socket, connectedUsers) => {
  /**
   * Join lobby
   * Client sends: { }
   * Server responds via callback: { success, data: { rooms, stats, onlineUsers } }
   */
  socket.on(EVENTS.LOBBY.JOIN, asyncHandler(async (data, callback) => {
    // Join lobby room
    socket.join('lobby');
    logger.debug(`Socket ${socket.id} joined lobby`);

    // If user is authenticated, check for active room
    let activeRoom = null;
    if (socket.user) {
      const userRooms = await Room.find({
        'players.userId': socket.user.userId,
        status: { $ne: 'finished' }
      }).limit(1);

      if (userRooms.length > 0) {
        activeRoom = userRooms[0];
        socket.join(`room:${activeRoom._id}`);
      }
    }

    // Fetch lobby data
    const [rooms, stats] = await Promise.all([
      Room.find({ status: { $ne: 'finished' }, isPrivate: false })
        .sort({ createdAt: -1 })
        .limit(50)
        .lean(),
      getLobbyStats()
    ]);

    const onlineUsers = Array.from(connectedUsers.values());

    // Send response
    const response = {
      success: true,
      data: {
        rooms,
        stats,
        onlineUsers,
        activeRoom: activeRoom ? { id: activeRoom._id.toString(), name: activeRoom.name } : null
      },
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    } else {
      socket.emit(EVENTS.LOBBY.ROOM_LIST, response);
    }
  }));

  /**
   * Leave lobby
   */
  socket.on(EVENTS.LOBBY.LEAVE, asyncHandler(async (data, callback) => {
    socket.leave('lobby');
    logger.debug(`Socket ${socket.id} left lobby`);

    const response = {
      success: true,
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    }
  }));

  /**
   * Get lobby stats
   */
  socket.on(EVENTS.LOBBY.STATS, asyncHandler(async (data, callback) => {
    const stats = await getLobbyStats();
    const onlineUsers = Array.from(connectedUsers.values());

    const response = {
      success: true,
      data: { stats, onlineUsers },
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    } else {
      socket.emit(EVENTS.LOBBY.STATS, response);
    }
  }));
};

/**
 * Get lobby statistics
 */
async function getLobbyStats() {
  const [totalRooms, waitingRooms, playingRooms, totalPlayers] = await Promise.all([
    Room.countDocuments({ status: { $ne: 'finished' } }),
    Room.countDocuments({ status: 'waiting' }),
    Room.countDocuments({ status: 'playing' }),
    Room.aggregate([
      { $match: { status: { $ne: 'finished' } } },
      { $project: { playerCount: { $size: '$players' } } },
      { $group: { _id: null, total: { $sum: '$playerCount' } } }
    ])
  ]);

  return {
    totalRooms,
    waitingRooms,
    playingRooms,
    totalPlayers: totalPlayers[0]?.total || 0
  };
}

module.exports = { registerLobbyHandlers, getLobbyStats };
```
</action>
  <verify>
Check file exists and:
- Imports Room model, EVENTS, asyncHandler
- Exports registerLobbyHandlers function
- Handles lobby:join, lobby:leave, lobby:stats events
- Uses asyncHandler wrapper for error handling
- Fetches rooms from database and returns via callback
  </verify>
  <done>
- backend/src/modules/socket/handlers/lobby.js created
- registerLobbyHandlers exports lobby event handlers
- lobby:join joins 'lobby' room and returns room list
- lobby:stats returns lobby statistics
- Uses asyncHandler for error catching
  </done>
</task>

<task type="auto">
  <name>Task 3: Create room event handlers</name>
  <files>
    backend/src/modules/socket/handlers/room.js
  </files>
  <action>
Create `backend/src/modules/socket/handlers/room.js`:

```javascript
/**
 * Room event handlers
 */
const { Room } = require('../../rooms/room.model.js');
const { EVENTS } = require('../utils/events.js');
const { asyncHandler } = require('../middleware/error.js');
const { logger } = require('../../../utils/logger.js');

// Track socket to room mapping (shared with other handlers)
const socketRooms = new Map(); // socketId -> roomId

/**
 * Register room event handlers
 * @param {Object} io - Socket.io instance
 * @param {Object} socket - Socket instance
 * @param {Map} connectedUsers - Map of connected users
 */
const registerRoomHandlers = (io, socket, connectedUsers) => {
  /**
   * Create new room
   * Requires authentication
   */
  socket.on(EVENTS.ROOM.CREATE, asyncHandler(async (data, callback) => {
    // Require authentication
    if (!socket.user) {
      throw new Error('Authentication required');
    }

    const { name, mode, maxPlayers, isPrivate, difficulty, timer } = data;

    // Create room
    const room = await Room.create({
      name: name || `Room-${Date.now().toString(36).toUpperCase().slice(-6)}`,
      mode: mode || 'debug',
      maxPlayers: maxPlayers || 4,
      isPrivate: isPrivate || false,
      difficulty: difficulty || 'medium',
      timer: timer || 15,
      createdBy: socket.user.userId,
      players: [{
        userId: socket.user.userId,
        username: socket.user.username,
        isReady: true,
        joinedAt: new Date()
      }]
    });

    await room.populate('players.userId', 'username rating');

    // Join socket to room
    socket.join(`room:${room._id}`);
    socketRooms.set(socket.id, room._id.toString());

    logger.info(`Room created: ${room.name} (${room._id}) by ${socket.user.username}`);

    // Broadcast to lobby
    io.to('lobby').emit(EVENTS.ROOM.CREATED, {
      room: room.toObject(),
      timestamp: new Date().toISOString()
    });

    // Send response
    const response = {
      success: true,
      data: { room: room.toObject() },
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    }
  }));

  /**
   * Join existing room
   * Requires authentication
   */
  socket.on(EVENTS.ROOM.JOIN, asyncHandler(async (data, callback) => {
    if (!socket.user) {
      throw new Error('Authentication required');
    }

    const { roomId } = data;

    // Find room
    const room = await Room.findById(roomId);
    if (!room) {
      throw new Error('Room not found');
    }

    // Check if can join
    if (!room.canJoin()) {
      throw new Error('Room is not available for joining');
    }

    // Check if already in room
    const isAlreadyInRoom = room.players.some(
      p => p.userId.toString() === socket.user.userId
    );

    // Leave previous room if any
    const prevRoomId = socketRooms.get(socket.id);
    if (prevRoomId && prevRoomId !== roomId) {
      await leaveRoomInternal(io, socket, prevRoomId);
    }

    // Add player to room (if not already in)
    if (!isAlreadyInRoom) {
      await room.addPlayer(socket.user.userId, socket.user.username);
    }

    await room.populate('players.userId', 'username rating');

    // Join socket to room
    socket.join(`room:${room._id}`);
    socketRooms.set(socket.id, room._id.toString());

    logger.info(`Player ${socket.user.username} joined room ${room.name}`);

    // Notify room (if new join)
    if (!isAlreadyInRoom) {
      socket.to(`room:${room._id}`).emit(EVENTS.ROOM.PLAYER_JOINED, {
        roomId: room._id.toString(),
        player: {
          userId: socket.user.userId,
          username: socket.user.username
        },
        timestamp: new Date().toISOString()
      });
    }

    // Broadcast room update to lobby
    io.to('lobby').emit(EVENTS.ROOM.UPDATE, {
      room: room.toObject(),
      timestamp: new Date().toISOString()
    });

    const response = {
      success: true,
      data: { room: room.toObject() },
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    }
  }));

  /**
   * Leave room
   */
  socket.on(EVENTS.ROOM.LEAVE, asyncHandler(async (data, callback) => {
    if (!socket.user) {
      throw new Error('Authentication required');
    }

    const { roomId } = data;
    await leaveRoomInternal(io, socket, roomId);

    const response = {
      success: true,
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    }
  }));

  /**
   * Toggle player ready status
   */
  socket.on(EVENTS.ROOM.PLAYER_READY, asyncHandler(async (data, callback) => {
    if (!socket.user) {
      throw new Error('Authentication required');
    }

    const { roomId, isReady } = data;

    const room = await Room.findById(roomId);
    if (!room) {
      throw new Error('Room not found');
    }

    // Update player ready status
    const player = room.players.find(
      p => p.userId.toString() === socket.user.userId
    );

    if (!player) {
      throw new Error('You are not in this room');
    }

    player.isReady = isReady ?? !player.isReady;
    await room.save();

    // Notify room
    io.to(`room:${room._id}`).emit(EVENTS.ROOM.PLAYER_READY, {
      roomId: room._id.toString(),
      player: {
        userId: socket.user.userId,
        username: socket.user.username,
        isReady: player.isReady
      },
      timestamp: new Date().toISOString()
    });

    const response = {
      success: true,
      data: { isReady: player.isReady },
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    }
  }));

  /**
   * Handle disconnect - cleanup
   */
  socket.on('disconnect', () => {
    const roomId = socketRooms.get(socket.id);
    if (roomId && socket.user) {
      // Grace period before removing (allow reconnection)
      setTimeout(async () => {
        // Check if user reconnected with different socket
        let isReconnected = false;
        for (const [sid, user] of connectedUsers.entries()) {
          if (user.userId === socket.user.userId && sid !== socket.id) {
            isReconnected = true;
            break;
          }
        }

        if (!isReconnected) {
          try {
            await leaveRoomInternal(io, socket, roomId, true);
          } catch (error) {
            logger.error('Error in disconnect cleanup:', error);
          }
        }
      }, 5000); // 5 second grace period
    }
    socketRooms.delete(socket.id);
  });

  return { socketRooms };
};

/**
 * Internal helper: Leave room
 */
async function leaveRoomInternal(io, socket, roomId, isDisconnect = false) {
  const room = await Room.findById(roomId);
  if (!room) return;

  const userId = socket.user?.userId;
  if (!userId) return;

  // Remove player from room
  await room.removePlayer(userId);

  // Notify room
  io.to(`room:${roomId}`).emit(EVENTS.ROOM.PLAYER_LEFT, {
    roomId,
    player: {
      userId,
      username: socket.user.username
    },
    timestamp: new Date().toISOString()
  });

  // Leave socket from room
  socket.leave(`room:${roomId}`);

  // Check if room still exists
  const updatedRoom = await Room.findById(roomId);
  if (updatedRoom) {
    await updatedRoom.populate('players.userId', 'username rating');
    io.to('lobby').emit(EVENTS.ROOM.UPDATE, {
      room: updatedRoom.toObject(),
      timestamp: new Date().toISOString()
    });
  } else {
    // Room was deleted (empty)
    io.to('lobby').emit(EVENTS.ROOM.DELETE, {
      roomId,
      timestamp: new Date().toISOString()
    });
  }

  if (!isDisconnect) {
    logger.info(`Player ${socket.user.username} left room ${room.name || roomId}`);
  }
}

module.exports = { registerRoomHandlers };
```
</action>
  <verify>
Check file exists and:
- Exports registerRoomHandlers function
- Handles room:create, room:join, room:leave, room:player_ready events
- Requires authentication for protected events
- Broadcasts room:created, room:update, room:delete to lobby
- Handles disconnect with grace period
  </verify>
  <done>
- backend/src/modules/socket/handlers/room.js created
- registerRoomHandlers exports room event handlers
- room:create creates room and broadcasts to lobby
- room:join adds player and broadcasts updates
- Disconnect handler with 5-second grace period
  </done>
</task>

<task type="auto">
  <name>Task 4: Update socket index to register handlers</name>
  <files>
    backend/src/modules/socket/index.js
  </files>
  <action>
Update `backend/src/modules/socket/index.js` to import and register lobby and room handlers:

Add imports at top:
```javascript
const { registerLobbyHandlers } = require('./handlers/lobby.js');
const { registerRoomHandlers } = require('./handlers/room.js');
```

Inside the `io.on('connection', (socket) => { ... })` block, after the existing code, add:

```javascript
    // Register lobby handlers
    registerLobbyHandlers(io, socket, connectedUsers);

    // Register room handlers
    const { socketRooms: roomSockets } = registerRoomHandlers(io, socket, connectedUsers);
    
    // Merge room socket tracking
    socketRooms = roomSockets;
```

Also need to make socketRooms accessible to handlers. Change the socketRooms declaration to be exported or passed appropriately.

Full updated index.js structure should:
1. Import registerLobbyHandlers and registerRoomHandlers
2. Export socketRooms map for access by handlers
3. Call both register functions inside connection handler
4. Pass connectedUsers map to both handlers
</action>
  <verify>
Check backend/src/modules/socket/index.js:
- Imports registerLobbyHandlers and registerRoomHandlers
- Calls both in connection handler
- Passes connectedUsers to handlers
- Maintains socketRooms tracking
  </verify>
  <done>
- index.js imports and calls registerLobbyHandlers
- index.js imports and calls registerRoomHandlers
- Both handlers receive io, socket, connectedUsers
- Socket connection sets up all event handlers
  </done>
</task>

<task type="auto">
  <name>Task 5: Create frontend SocketContext</name>
  <files>
    code-arena/src/contexts/SocketContext.tsx
  </files>
  <action>
Create `code-arena/src/contexts/SocketContext.tsx`:

```typescript
import React, { createContext, useContext, useEffect, useState, useRef, ReactNode } from 'react';
import { io, Socket } from 'socket.io-client';
import { useAuth } from './AuthContext';

// API URL from environment or default
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';

// Event types matching backend
export const SOCKET_EVENTS = {
  LOBBY: {
    JOIN: 'lobby:join',
    LEAVE: 'lobby:leave',
    ROOM_LIST: 'lobby:room_list',
    STATS: 'lobby:stats',
  },
  ROOM: {
    CREATE: 'room:create',
    CREATED: 'room:created',
    JOIN: 'room:join',
    LEAVE: 'room:leave',
    UPDATE: 'room:update',
    DELETE: 'room:delete',
    PLAYER_JOINED: 'room:player_joined',
    PLAYER_LEFT: 'room:player_left',
    PLAYER_READY: 'room:player_ready',
  },
  PLAYER: {
    ONLINE: 'player:online',
    OFFLINE: 'player:offline',
  },
  SYSTEM: {
    ERROR: 'system:error',
    CONNECTED: 'system:connected',
    PING: 'system:ping',
    PONG: 'system:pong',
  },
} as const;

interface SocketContextType {
  socket: Socket | null;
  isConnected: boolean;
  connectionError: string | null;
  onlineUsers: number;
  connect: () => void;
  disconnect: () => void;
}

const SocketContext = createContext<SocketContextType | undefined>(undefined);

interface SocketProviderProps {
  children: ReactNode;
}

export const SocketProvider: React.FC<SocketProviderProps> = ({ children }) => {
  const { isAuthenticated } = useAuth();
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const [onlineUsers, setOnlineUsers] = useState(0);
  const socketRef = useRef<Socket | null>(null);

  // Initialize socket connection
  const connect = () => {
    if (socketRef.current?.connected) {
      return;
    }

    const newSocket = io(API_URL, {
      withCredentials: true, // Important: sends httpOnly cookies
      transports: ['websocket', 'polling'], // Fallback support
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
    });

    newSocket.on('connect', () => {
      console.log('[Socket] Connected:', newSocket.id);
      setIsConnected(true);
      setConnectionError(null);
    });

    newSocket.on('disconnect', (reason) => {
      console.log('[Socket] Disconnected:', reason);
      setIsConnected(false);
    });

    newSocket.on('connect_error', (error) => {
      console.error('[Socket] Connection error:', error.message);
      setConnectionError(error.message);
      setIsConnected(false);
    });

    newSocket.on(SOCKET_EVENTS.SYSTEM.CONNECTED, (data) => {
      console.log('[Socket] Server acknowledged connection:', data);
    });

    newSocket.on(SOCKET_EVENTS.SYSTEM.ERROR, (error) => {
      console.error('[Socket] Server error:', error);
    });

    newSocket.on(SOCKET_EVENTS.PLAYER.ONLINE, (data) => {
      setOnlineUsers(prev => prev + 1);
      console.log('[Socket] Player online:', data.username);
    });

    newSocket.on(SOCKET_EVENTS.PLAYER.OFFLINE, (data) => {
      setOnlineUsers(prev => Math.max(0, prev - 1));
      console.log('[Socket] Player offline:', data.username);
    });

    socketRef.current = newSocket;
    setSocket(newSocket);
  };

  // Disconnect socket
  const disconnect = () => {
    if (socketRef.current) {
      socketRef.current.disconnect();
      socketRef.current = null;
      setSocket(null);
      setIsConnected(false);
    }
  };

  // Auto-connect when authenticated
  useEffect(() => {
    if (isAuthenticated) {
      connect();
    } else {
      disconnect();
    }

    return () => {
      disconnect();
    };
  }, [isAuthenticated]);

  // Ping health check every 30 seconds
  useEffect(() => {
    if (!isConnected || !socket) return;

    const interval = setInterval(() => {
      socket.emit(SOCKET_EVENTS.SYSTEM.PING, {}, (response: { pong: boolean }) => {
        if (!response?.pong) {
          console.warn('[Socket] Ping failed');
        }
      });
    }, 30000);

    return () => clearInterval(interval);
  }, [isConnected, socket]);

  const value: SocketContextType = {
    socket,
    isConnected,
    connectionError,
    onlineUsers,
    connect,
    disconnect,
  };

  return <SocketContext.Provider value={value}>{children}</SocketContext.Provider>;
};

export const useSocket = (): SocketContextType => {
  const context = useContext(SocketContext);
  if (context === undefined) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
};

export default SocketContext;
```
</action>
  <verify>
Check file exists and:
- Imports io from socket.io-client
- Creates SocketContext with socket, isConnected, onlineUsers
- useSocket hook exported
- SocketProvider auto-connects when authenticated
- Uses withCredentials: true for cookie auth
  </verify>
  <done>
- code-arena/src/contexts/SocketContext.tsx created
- Exports SocketProvider and useSocket hook
- SOCKET_EVENTS constants match backend
- Auto-connects when user authenticated
- Health check ping every 30 seconds
  </done>
</task>

<task type="auto">
  <name>Task 6: Update App.tsx with SocketProvider</name>
  <files>
    code-arena/src/App.tsx
  </files>
  <action>
Update `code-arena/src/App.tsx` to wrap the app with SocketProvider.

Find the AuthProvider wrapping and add SocketProvider inside it:

```tsx
// Add import at top
import { SocketProvider } from './contexts/SocketContext';

// Wrap routes with SocketProvider inside AuthProvider
<AuthProvider>
  <SocketProvider>
    {/* existing routes/content */}
  </SocketProvider>
</AuthProvider>
```

The SocketProvider must be inside AuthProvider so it can access isAuthenticated state via useAuth().
</action>
  <verify>
Check code-arena/src/App.tsx:
- Imports SocketProvider from './contexts/SocketContext'
- SocketProvider wraps routes/content inside AuthProvider
- Component hierarchy: AuthProvider -> SocketProvider -> Routes
  </verify>
  <done>
- App.tsx imports SocketProvider
- SocketProvider wraps the application inside AuthProvider
- SocketContext can access AuthContext state
  </done>
</task>

<task type="auto">
  <name>Task 7: Update Lobby.tsx to use socket events</name>
  <files>
    code-arena/src/pages/app/Lobby.tsx
  </files>
  <action>
Update `code-arena/src/pages/app/Lobby.tsx` to use socket events instead of polling.

Key changes needed:

1. Add imports:
```typescript
import { useSocket, SOCKET_EVENTS } from '@/contexts/SocketContext';
```

2. In the component, replace the polling useEffect with socket event handlers:

```typescript
const { socket, isConnected } = useSocket();

// Replace polling useEffect with socket events
useEffect(() => {
  if (!socket || !isConnected) return;

  // Join lobby and get initial data
  socket.emit(SOCKET_EVENTS.LOBBY.JOIN, {}, (response: any) => {
    if (response.success) {
      setRooms(response.data.rooms);
      setOnlineUsers(response.data.onlineUsers.length);
    }
  });

  // Listen for new rooms
  socket.on(SOCKET_EVENTS.ROOM.CREATED, (data: any) => {
    setRooms(prev => [data.room, ...prev]);
  });

  // Listen for room updates
  socket.on(SOCKET_EVENTS.ROOM.UPDATE, (data: any) => {
    setRooms(prev => prev.map(room => 
      room._id === data.room._id ? data.room : room
    ));
  });

  // Listen for room deletions
  socket.on(SOCKET_EVENTS.ROOM.DELETE, (data: any) => {
    setRooms(prev => prev.filter(room => room._id !== data.roomId));
  });

  return () => {
    socket.emit(SOCKET_EVENTS.LOBBY.LEAVE, {});
    socket.off(SOCKET_EVENTS.ROOM.CREATED);
    socket.off(SOCKET_EVENTS.ROOM.UPDATE);
    socket.off(SOCKET_EVENTS.ROOM.DELETE);
  };
}, [socket, isConnected]);
```

3. Update create room handler to use socket:
```typescript
const handleCreateRoom = async (e: React.FormEvent) => {
  e.preventDefault();
  
  if (!socket) return;

  socket.emit(SOCKET_EVENTS.ROOM.CREATE, {
    name: roomName || undefined,
    mode: gameMode,
    maxPlayers: maxPlayers,
    isPrivate: isPrivate,
    difficulty: difficulty,
    timer: timer
  }, (response: any) => {
    if (response.success) {
      setIsCreateDialogOpen(false);
      toast.success('Room created successfully!');
      navigate(`/app/room/${response.data.room._id}`);
    } else {
      toast.error(response.error || 'Failed to create room');
    }
  });
};
```

4. Update join room handler similarly to use socket.emit(SOCKET_EVENTS.ROOM.JOIN, ...)
</action>
  <verify>
Check code-arena/src/pages/app/Lobby.tsx:
- Imports useSocket and SOCKET_EVENTS
- Uses socket.emit for lobby:join to get room list
- Listens to room:created, room:update, room:delete events
- Uses socket.emit for room:create
- Removes polling useEffect (or replaces with socket-based)
  </verify>
  <done>
- Lobby.tsx uses socket events instead of polling
- Initial room list fetched via lobby:join
- Real-time updates via room:created, room:update, room:delete
- Create room uses socket.emit
- Join room uses socket.emit
  </done>
</task>

</tasks>

<verification>
1. `cd code-arena && npm list socket.io-client` - installed
2. Backend lobby handlers respond to lobby:join, lobby:leave events
3. Backend room handlers respond to room:create, room:join, room:leave events
4. Frontend SocketContext provides socket instance
5. Lobby page uses socket.emit() instead of fetch/polling
6. Real-time updates work (create room shows instantly in lobby)
</verification>

<success_criteria>
- SocketContext provides socket connection to all components
- Lobby page receives room list via socket (lobby:join)
- Room creation broadcasts to lobby in real-time (room:created)
- Room updates broadcast to lobby (room:update, room:delete)
- Error handling wrapper catches and logs errors
- Polling removed from Lobby (replaced with sockets)
</success_criteria>

<output>
After completion, create `.planning/phases/02-realtime/02-02-SUMMARY.md`
</output>
