---
phase: 02-realtime
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/server.js
  - backend/src/config/socket.js
  - backend/src/config/redis.js
  - backend/src/modules/socket/index.js
  - backend/src/modules/socket/middleware/auth.js
  - backend/src/modules/socket/utils/events.js
  - backend/package.json
autonomous: true
must_haves:
  truths:
    - "Socket.io server uses Redis adapter for multi-server scaling"
    - "Socket authentication reads JWT from httpOnly cookies"
    - "Socket.io uses domain:action event naming convention"
    - "Socket errors are caught and logged without crashing server"
  artifacts:
    - path: "backend/src/config/redis.js"
      provides: "Redis adapter setup for Socket.io"
      exports: ["setupRedisAdapter"]
    - path: "backend/src/modules/socket/middleware/auth.js"
      provides: "Cookie-based socket authentication"
      exports: ["socketAuthMiddleware"]
    - path: "backend/src/modules/socket/utils/events.js"
      provides: "Event constants with domain:action naming"
      exports: ["EVENTS"]
    - path: "backend/src/modules/socket/index.js"
      provides: "Socket.io initialization with middleware"
      exports: ["initializeSocket"]
  key_links:
    - from: "backend/src/server.js"
      to: "backend/src/modules/socket/index.js"
      via: "import and call initializeSocket"
    - from: "backend/src/modules/socket/middleware/auth.js"
      to: "socket.handshake.headers.cookie"
      via: "cookie.parse() to extract accessToken"
    - from: "backend/src/config/redis.js"
      to: "@socket.io/redis-adapter"
      via: "createAdapter(pubClient, subClient)"
---

<objective>
Set up production-ready Socket.io server with Redis adapter for horizontal scaling and cookie-based JWT authentication.

Purpose: Enable real-time features with proper authentication and multi-server support for production deployment.
Output: Socket.io server with Redis adapter, cookie auth middleware, and standardized event constants.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-realtime/02-RESEARCH.md
@backend/src/server.js
@backend/src/config/socket.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create Redis adapter</name>
  <files>
    backend/package.json
    backend/src/config/redis.js
  </files>
  <action>
Install required dependencies:
```bash
cd backend && npm install @socket.io/redis-adapter cookie
```

Create `backend/src/config/redis.js` with Redis adapter setup:
- Import `createClient` from redis and `createAdapter` from @socket.io/redis-adapter
- Export `setupRedisAdapter(io)` async function that:
  - Creates pubClient with url from env.REDIS_URL
  - Creates subClient as pubClient.duplicate()
  - Awaits Promise.all([pubClient.connect(), subClient.connect()])
  - Calls io.adapter(createAdapter(pubClient, subClient))
  - Logs 'Redis adapter connected' on success
  - Sets up error handlers on both clients
  - Handles connection errors gracefully (log but don't crash)
</action>
  <verify>
```bash
cd backend && npm list @socket.io/redis-adapter cookie
```
Should show both packages installed. Check redis.js exports setupRedisAdapter function.
  </verify>
  <done>
- @socket.io/redis-adapter and cookie packages installed
- backend/src/config/redis.js created with setupRedisAdapter function
- Function properly configures pub/sub Redis clients and adapter
  </done>
</task>

<task type="auto">
  <name>Task 2: Create socket event constants</name>
  <files>
    backend/src/modules/socket/utils/events.js
  </files>
  <action>
Create `backend/src/modules/socket/utils/events.js` with domain:action naming convention:

```javascript
/**
 * Socket event constants
 * Uses domain:action naming for consistency
 */
const EVENTS = {
  // Lobby domain
  LOBBY: {
    JOIN: 'lobby:join',
    LEAVE: 'lobby:leave',
    ROOM_LIST: 'lobby:room_list',
    STATS: 'lobby:stats',
    USER_JOINED: 'lobby:user_joined',
    USER_LEFT: 'lobby:user_left'
  },

  // Room domain
  ROOM: {
    CREATE: 'room:create',
    CREATED: 'room:created',
    JOIN: 'room:join',
    LEAVE: 'room:leave',
    UPDATE: 'room:update',
    DELETE: 'room:delete',
    PLAYER_JOINED: 'room:player_joined',
    PLAYER_LEFT: 'room:player_left',
    PLAYER_READY: 'room:player_ready',
    CHAT_MESSAGE: 'room:chat_message'
  },

  // Match domain
  MATCH: {
    START: 'match:start',
    STARTED: 'match:started',
    END: 'match:end',
    ENDED: 'match:ended',
    STATE_UPDATE: 'match:state_update'
  },

  // Player domain
  PLAYER: {
    ONLINE: 'player:online',
    OFFLINE: 'player:offline',
    STATUS_CHANGE: 'player:status_change'
  },

  // System domain
  SYSTEM: {
    ERROR: 'system:error',
    CONNECTED: 'system:connected',
    DISCONNECTED: 'system:disconnected',
    PING: 'system:ping',
    PONG: 'system:pong'
  }
};

module.exports = { EVENTS };
```
</action>
  <verify>
Check file exists and exports EVENTS object with all domains (LOBBY, ROOM, MATCH, PLAYER, SYSTEM).
  </verify>
  <done>
- backend/src/modules/socket/utils/events.js created
- Exports EVENTS constant with domain:action naming
- All event names follow pattern: domain:action (lowercase with colon)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create cookie-based authentication middleware</name>
  <files>
    backend/src/modules/socket/middleware/auth.js
  </files>
  <action>
Create `backend/src/modules/socket/middleware/auth.js`:

```javascript
/**
 * Socket.io authentication middleware
 * Reads JWT from httpOnly cookies
 */
const jwt = require('jsonwebtoken');
const cookie = require('cookie');
const { User } = require('../../users/user.model.js');
const { env } = require('../../../config/env.js');
const { logger } = require('../../../utils/logger.js');

/**
 * Socket authentication middleware
 * Extracts JWT from httpOnly cookie and attaches user to socket
 * Allows unauthenticated connections for public lobby viewing
 */
const socketAuthMiddleware = async (socket, next) => {
  try {
    // Parse cookies from handshake headers
    const cookies = cookie.parse(socket.handshake.headers.cookie || '');
    const token = cookies.accessToken;

    if (!token) {
      // Allow unauthenticated connections for public lobby
      return next();
    }

    // Verify JWT
    const decoded = jwt.verify(token, env.JWT_SECRET);

    // Find user
    const user = await User.findById(decoded.userId);

    if (user && user.isActive) {
      // Attach user to socket
      socket.user = {
        userId: user._id.toString(),
        username: user.username,
        role: user.role
      };
      
      logger.debug(`Socket authenticated: ${socket.user.username} (${socket.id})`);
    }

    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      logger.debug(`Token expired for socket ${socket.id}`);
      // Let client handle re-auth, don't block connection
      return next();
    }

    if (error.name === 'JsonWebTokenError') {
      logger.debug(`Invalid token for socket ${socket.id}`);
      return next();
    }

    // Log unexpected errors but don't block connection
    logger.error('Socket auth error:', error);
    next();
  }

  /**
   * Require authentication middleware
   * Use this wrapper for protected events
   */
  const requireAuth = (socket) => {
    if (!socket.user) {
      throw new Error('Authentication required');
    }
    return socket.user;
  };

  module.exports = { socketAuthMiddleware, requireAuth };
};

module.exports = { socketAuthMiddleware };
```
</action>
  <verify>
Check file exists and exports socketAuthMiddleware that:
- Uses cookie.parse() on socket.handshake.headers.cookie
- Extracts accessToken from cookies
- Verifies JWT with env.JWT_SECRET
- Attaches user object to socket
- Allows unauthenticated connections to proceed
  </verify>
  <done>
- backend/src/modules/socket/middleware/auth.js created
- socketAuthMiddleware parses httpOnly cookies using cookie library
- JWT verification uses env.JWT_SECRET
- User object attached to socket with userId, username, role
- Expired/invalid tokens don't block connection (for public lobby)
  </done>
</task>

<task type="auto">
  <name>Task 4: Create modular socket initialization</name>
  <files>
    backend/src/modules/socket/index.js
  </files>
  <action>
Create `backend/src/modules/socket/index.js` as the main socket entry point:

```javascript
/**
 * Socket.io initialization
 * Modular structure with middleware and handlers
 */
const { socketAuthMiddleware } = require('./middleware/auth.js');
const { EVENTS } = require('./utils/events.js');
const { logger } = require('../../utils/logger.js');

// Maps for tracking connections
const connectedUsers = new Map(); // socketId -> { userId, username }
const socketRooms = new Map();    // socketId -> roomId
const userSockets = new Map();    // userId -> socketId (for reconnection tracking)

/**
 * Initialize socket.io with all handlers
 * @param {Object} io - Socket.io instance
 */
const initializeSocket = (io) => {
  // Apply authentication middleware
  io.use(socketAuthMiddleware);

  // Handle connection errors
  io.on('connect_error', (err) => {
    logger.error('Socket connection error:', err.message);
  });

  io.on('connection', (socket) => {
    logger.debug(`Socket connected: ${socket.id}`);

    // Track authenticated users
    if (socket.user) {
      connectedUsers.set(socket.id, socket.user);
      userSockets.set(socket.user.userId, socket.id);

      // Notify others this user is online
      socket.broadcast.emit(EVENTS.PLAYER.ONLINE, {
        userId: socket.user.userId,
        username: socket.user.username,
        timestamp: new Date().toISOString()
      });
    }

    // Send connected event
    socket.emit(EVENTS.SYSTEM.CONNECTED, {
      socketId: socket.id,
      timestamp: new Date().toISOString()
    });

    // Handle ping/pong for connection health
    socket.on(EVENTS.SYSTEM.PING, (data, callback) => {
      if (typeof callback === 'function') {
        callback({ pong: true, timestamp: new Date().toISOString() });
      } else {
        socket.emit(EVENTS.SYSTEM.PONG, { timestamp: new Date().toISOString() });
      }
    });

    // Handle disconnection
    socket.on('disconnect', (reason) => {
      logger.debug(`Socket disconnected: ${socket.id}, reason: ${reason}`);

      const user = connectedUsers.get(socket.id);

      if (user) {
        connectedUsers.delete(socket.id);
        userSockets.delete(user.userId);

        // Notify others this user is offline
        socket.broadcast.emit(EVENTS.PLAYER.OFFLINE, {
          userId: user.userId,
          username: user.username,
          timestamp: new Date().toISOString()
        });
      }

      socketRooms.delete(socket.id);
    });

    // TODO: Lobby and room handlers will be added in next plans
    // These will be imported from ./handlers/lobby.js and ./handlers/room.js
  });

  return io;
};

/**
 * Get connected users count
 */
const getOnlineUsers = () => Array.from(connectedUsers.values());

/**
 * Get connected users count
 */
const getOnlineCount = () => connectedUsers.size;

/**
 * Check if user is online
 */
const isUserOnline = (userId) => {
  for (const user of connectedUsers.values()) {
    if (user.userId === userId) return true;
  }
  return false;
};

module.exports = {
  initializeSocket,
  getOnlineUsers,
  getOnlineCount,
  isUserOnline,
  connectedUsers,
  socketRooms,
  userSockets
};
```
</action>
  <verify>
Check file exists and:
- Imports socketAuthMiddleware and applies it with io.use()
- Exports initializeSocket function
- Sets up connectedUsers, socketRooms, userSockets Maps
- Handles connection/disconnection with logging
- Implements ping/pong for connection health
  </verify>
  <done>
- backend/src/modules/socket/index.js created
- initializeSocket applies auth middleware
- Connection tracking Maps initialized
- Ping/pong health check implemented
- Disconnect handler with proper cleanup
  </done>
</task>

<task type="auto">
  <name>Task 5: Update server.js with Redis adapter and production config</name>
  <files>
    backend/src/server.js
  </files>
  <action>
Update `backend/src/server.js` to:
1. Import setupRedisAdapter
2. Add production-ready Socket.io configuration
3. Call setupRedisAdapter before initializeSocket
4. Use the new modular socket initialization

Changes needed:
- Add `const { setupRedisAdapter } = require('./config/redis.js');`
- Update Socket.io config to include:
  - pingTimeout: 60000
  - pingInterval: 25000
  - transports: ['websocket', 'polling']
  - connectionStateRecovery with maxDisconnectionDuration: 2 * 60 * 1000
- Use same CORS options as Express (use env.CORS_ORIGIN)
- After creating io, await setupRedisAdapter(io)
- Change require path from './config/socket.js' to './modules/socket/index.js'

Example structure:
```javascript
// ... existing imports ...
const { setupRedisAdapter } = require('./config/redis.js');

const startServer = async () => {
  try {
    await connectDB();
    
    const httpServer = app.listen(PORT, () => { ... });
    
    // Initialize Socket.io with production config
    const { initializeSocket } = require('./modules/socket/index.js');
    const { Server } = require('socket.io');
    
    const io = new Server(httpServer, {
      cors: {
        origin: env.CORS_ORIGIN?.split(',') || ['http://localhost:5173'],
        credentials: true
      },
      pingTimeout: 60000,
      pingInterval: 25000,
      transports: ['websocket', 'polling'],
      connectionStateRecovery: {
        maxDisconnectionDuration: 2 * 60 * 1000,
        skipMiddlewares: true
      }
    });
    
    // Setup Redis adapter for multi-server scaling
    await setupRedisAdapter(io);
    
    // Initialize socket handlers
    initializeSocket(io);
    
    return httpServer;
  } catch (error) { ... }
};
```
</action>
  <verify>
```bash
cd backend && node -e "const { setupRedisAdapter } = require('./src/config/redis.js'); console.log('Redis adapter export OK');"
```
Check server.js:
- Imports setupRedisAdapter from ./config/redis.js
- Socket.io config has pingTimeout, pingInterval, transports, connectionStateRecovery
- Calls await setupRedisAdapter(io) before initializeSocket
- Uses new path ./modules/socket/index.js
  </verify>
  <done>
- server.js imports setupRedisAdapter
- Socket.io uses production config (pingTimeout: 60000, etc.)
- Redis adapter initialized before socket handlers
- Uses modular socket initialization from ./modules/socket/index.js
  </done>
</task>

</tasks>

<verification>
1. Run `cd backend && npm list @socket.io/redis-adapter cookie` - both installed
2. Check backend/src/config/redis.js exports setupRedisAdapter
3. Check backend/src/modules/socket/middleware/auth.js uses cookie.parse()
4. Check backend/src/modules/socket/utils/events.js has domain:action naming
5. Check backend/src/modules/socket/index.js applies auth middleware
6. Check backend/src/server.js calls setupRedisAdapter and has production config
</verification>

<success_criteria>
- @socket.io/redis-adapter and cookie packages installed
- Redis adapter configured for multi-server scaling
- Cookie-based JWT authentication reads from httpOnly cookies
- Socket.io production config (ping timeouts, state recovery)
- Domain:action event naming convention established
- Modular socket structure in place
</success_criteria>

<output>
After completion, create `.planning/phases/02-realtime/02-01-SUMMARY.md`
</output>
