---
phase: 02-realtime
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/modules/socket/handlers/chat.js
  - backend/src/modules/socket/handlers/room.js
  - code-arena/src/pages/app/Room.tsx
  - code-arena/src/components/ChatPanel.tsx
  - code-arena/src/components/PlayerList.tsx
autonomous: true
must_haves:
  truths:
    - "Players in a room see real-time player list with ready status"
    - "Room chat messages appear instantly for all room members"
    - "Host can start match when all players are ready"
    - "Players can toggle ready status in real-time"
    - "Leaving room updates player list for remaining players"
  artifacts:
    - path: "backend/src/modules/socket/handlers/chat.js"
      provides: "Room chat event handlers"
      exports: ["registerChatHandlers"]
    - path: "code-arena/src/pages/app/Room.tsx"
      provides: "Room page with socket integration"
      contains: ["useSocket", "socket.emit", "socket.on"]
    - path: "code-arena/src/components/ChatPanel.tsx"
      provides: "Chat UI component with socket events"
      contains: ["room:chat_message"]
    - path: "code-arena/src/components/PlayerList.tsx"
      provides: "Player list with ready status"
      contains: ["room:player_ready"]
  key_links:
    - from: "backend/src/modules/socket/handlers/chat.js"
      to: "EVENTS.ROOM.CHAT_MESSAGE"
      via: "socket.on(EVENTS.ROOM.CHAT_MESSAGE, ...)"
    - from: "code-arena/src/pages/app/Room.tsx"
      to: "code-arena/src/contexts/SocketContext.tsx"
      via: "const { socket } = useSocket()"
    - from: "code-arena/src/components/ChatPanel.tsx"
      to: "socket.emit(EVENTS.ROOM.CHAT_MESSAGE)"
      via: "onSendMessage handler"
---

<objective>
Implement room-specific socket features including chat, ready status toggle, and real-time player list updates in the room page.

Purpose: Enable real-time collaboration in game rooms with chat and ready status before matches start.
Output: Room page with live player list, chat functionality, and ready status toggle.
</objective>

<execution_context>
@C:/Users/HP/.config/opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-realtime/02-RESEARCH.md
@code-arena/src/pages/app/Room.tsx
@backend/src/modules/socket/handlers/room.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat event handlers</name>
  <files>
    backend/src/modules/socket/handlers/chat.js
    backend/src/modules/socket/index.js
  </files>
  <action>
Create `backend/src/modules/socket/handlers/chat.js`:

```javascript
/**
 * Chat event handlers
 */
const { EVENTS } = require('../utils/events.js');
const { asyncHandler } = require('../middleware/error.js');
const { logger } = require('../../../utils/logger.js');

// In-memory message cache per room (last 50 messages)
const roomMessages = new Map(); // roomId -> Array of messages

const MAX_MESSAGES_PER_ROOM = 50;

/**
 * Register chat event handlers
 * @param {Object} io - Socket.io instance
 * @param {Object} socket - Socket instance
 */
const registerChatHandlers = (io, socket) => {
  /**
   * Send chat message
   * Requires authentication and room membership
   */
  socket.on(EVENTS.ROOM.CHAT_MESSAGE, asyncHandler(async (data, callback) => {
    if (!socket.user) {
      throw new Error('Authentication required');
    }

    const { roomId, message, type = 'text' } = data;

    if (!roomId || !message) {
      throw new Error('Room ID and message are required');
    }

    // Validate message length
    if (message.length > 500) {
      throw new Error('Message too long (max 500 characters)');
    }

    // Check if socket is in the room
    const roomSockets = await io.in(`room:${roomId}`).fetchSockets();
    const isInRoom = roomSockets.some(s => s.id === socket.id);

    if (!isInRoom) {
      throw new Error('You are not in this room');
    }

    // Create message object
    const chatMessage = {
      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      roomId,
      userId: socket.user.userId,
      username: socket.user.username,
      message: message.trim(),
      type, // 'text', 'system', 'action'
      timestamp: new Date().toISOString()
    };

    // Store in cache
    if (!roomMessages.has(roomId)) {
      roomMessages.set(roomId, []);
    }
    const messages = roomMessages.get(roomId);
    messages.push(chatMessage);
    
    // Keep only last N messages
    if (messages.length > MAX_MESSAGES_PER_ROOM) {
      messages.shift();
    }

    // Broadcast to room (including sender)
    io.to(`room:${roomId}`).emit(EVENTS.ROOM.CHAT_MESSAGE, chatMessage);

    logger.debug(`Chat message in room ${roomId} from ${socket.user.username}`);

    if (typeof callback === 'function') {
      callback({
        success: true,
        data: { message: chatMessage },
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * Get recent chat history
   */
  socket.on('chat:history', asyncHandler(async (data, callback) => {
    const { roomId } = data;
    
    const messages = roomMessages.get(roomId) || [];
    
    if (typeof callback === 'function') {
      callback({
        success: true,
        data: { messages },
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * Send system message to room
   * (Used internally by other handlers)
   */
  socket.sendSystemMessage = (roomId, message) => {
    const systemMessage = {
      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      roomId,
      userId: 'system',
      username: 'System',
      message,
      type: 'system',
      timestamp: new Date().toISOString()
    };

    if (!roomMessages.has(roomId)) {
      roomMessages.set(roomId, []);
    }
    const messages = roomMessages.get(roomId);
    messages.push(systemMessage);
    
    if (messages.length > MAX_MESSAGES_PER_ROOM) {
      messages.shift();
    }

    io.to(`room:${roomId}`).emit(EVENTS.ROOM.CHAT_MESSAGE, systemMessage);
  };
};

/**
 * Clean up messages for a room (called when room is deleted)
 */
const cleanupRoomMessages = (roomId) => {
  roomMessages.delete(roomId);
  logger.debug(`Cleaned up messages for room ${roomId}`);
};

module.exports = { registerChatHandlers, cleanupRoomMessages };
```

Then update `backend/src/modules/socket/index.js` to register chat handlers:

Add import:
```javascript
const { registerChatHandlers } = require('./handlers/chat.js');
```

Inside connection handler, add:
```javascript
    // Register chat handlers
    registerChatHandlers(io, socket);
```
</action>
  <verify>
Check backend/src/modules/socket/handlers/chat.js:
- Exports registerChatHandlers function
- Handles room:chat_message event
- Validates message length (max 500 chars)
- Stores messages in memory cache
- Broadcasts messages to room

Check backend/src/modules/socket/index.js:
- Imports registerChatHandlers
- Calls registerChatHandlers(io, socket)
  </verify>
  <done>
- backend/src/modules/socket/handlers/chat.js created
- registerChatHandlers handles room:chat_message
- Message validation (length, room membership)
- In-memory message cache (last 50 per room)
- Chat handlers registered in socket index
  </done>
</task>

<task type="auto">
  <name>Task 2: Add match start handler to room handlers</name>
  <files>
    backend/src/modules/socket/handlers/room.js
  </files>
  <action>
Add match start handler to `backend/src/modules/socket/handlers/room.js`:

Inside registerRoomHandlers, add after the PLAYER_READY handler:

```javascript
  /**
   * Start match (host only)
   */
  socket.on(EVENTS.MATCH.START, asyncHandler(async (data, callback) => {
    if (!socket.user) {
      throw new Error('Authentication required');
    }

    const { roomId } = data;

    const room = await Room.findById(roomId);
    if (!room) {
      throw new Error('Room not found');
    }

    // Verify host
    if (room.createdBy.toString() !== socket.user.userId) {
      throw new Error('Only the host can start the match');
    }

    // Check minimum players
    if (room.players.length < 2) {
      throw new Error('Need at least 2 players to start');
    }

    // Check all players are ready (except in casual mode)
    const notReadyPlayers = room.players.filter(p => !p.isReady);
    if (notReadyPlayers.length > 0) {
      throw new Error('All players must be ready to start');
    }

    // Start the match
    await room.startMatch();

    // Send system message
    if (socket.sendSystemMessage) {
      socket.sendSystemMessage(roomId, 'Match is starting!');
    }

    // Broadcast to room
    io.to(`room:${room._id}`).emit(EVENTS.MATCH.STARTED, {
      roomId: room._id.toString(),
      matchId: room.currentMatchId,
      startedAt: room.matchStartedAt,
      timestamp: new Date().toISOString()
    });

    // Broadcast to lobby
    io.to('lobby').emit(EVENTS.ROOM.UPDATE, {
      room: room.toObject(),
      timestamp: new Date().toISOString()
    });

    logger.info(`Match started in room ${room.name} by ${socket.user.username}`);

    const response = {
      success: true,
      data: { room: room.toObject() },
      timestamp: new Date().toISOString()
    };

    if (typeof callback === 'function') {
      callback(response);
    }
  }));
```

Also add EVENTS.MATCH to the events import if not already there.
</action>
  <verify>
Check backend/src/modules/socket/handlers/room.js:
- Handles match:start event
- Verifies user is host
- Checks minimum 2 players
- Checks all players are ready
- Calls room.startMatch()
- Broadcasts match:started to room
- Broadcasts room:update to lobby
  </verify>
  <done>
- match:start handler added to room handlers
- Host verification implemented
- Minimum players check (2+)
- All players ready check
- Broadcasts match:started event
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ChatPanel component</name>
  <files>
    code-arena/src/components/ChatPanel.tsx
  </files>
  <action>
Create `code-arena/src/components/ChatPanel.tsx`:

```typescript
import React, { useState, useEffect, useRef } from 'react';
import { useSocket, SOCKET_EVENTS } from '@/contexts/SocketContext';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Send } from 'lucide-react';

interface ChatMessage {
  id: string;
  roomId: string;
  userId: string;
  username: string;
  message: string;
  type: 'text' | 'system' | 'action';
  timestamp: string;
}

interface ChatPanelProps {
  roomId: string;
  currentUser: { _id: string; username: string } | null;
}

export const ChatPanel: React.FC<ChatPanelProps> = ({ roomId, currentUser }) => {
  const { socket } = useSocket();
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const scrollRef = useRef<HTMLDivElement>(null);

  // Listen for messages
  useEffect(() => {
    if (!socket) return;

    // Get chat history
    socket.emit('chat:history', { roomId }, (response: any) => {
      if (response.success) {
        setMessages(response.data.messages);
      }
    });

    // Listen for new messages
    socket.on(SOCKET_EVENTS.ROOM.CHAT_MESSAGE, (message: ChatMessage) => {
      if (message.roomId === roomId) {
        setMessages(prev => [...prev, message]);
      }
    });

    return () => {
      socket.off(SOCKET_EVENTS.ROOM.CHAT_MESSAGE);
    };
  }, [socket, roomId]);

  // Auto-scroll to bottom
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [messages]);

  const handleSendMessage = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!socket || !inputMessage.trim()) return;

    socket.emit(SOCKET_EVENTS.ROOM.CHAT_MESSAGE, {
      roomId,
      message: inputMessage.trim()
    }, (response: any) => {
      if (!response.success) {
        console.error('Failed to send message:', response.error);
      }
    });

    setInputMessage('');
  };

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString([], { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
  };

  return (
    <div className="flex flex-col h-full border rounded-lg bg-card">
      <div className="p-3 border-b">
        <h3 className="font-semibold">Room Chat</h3>
      </div>

      <ScrollArea className="flex-1 p-4" ref={scrollRef}>
        <div className="space-y-3">
          {messages.length === 0 && (
            <p className="text-muted-foreground text-center text-sm">
              No messages yet. Start the conversation!
            </p>
          )}

          {messages.map((msg) => (
            <div
              key={msg.id}
              className={`flex flex-col ${
                msg.type === 'system' 
                  ? 'items-center' 
                  : msg.userId === currentUser?._id 
                    ? 'items-end' 
                    : 'items-start'
              }`}
            >
              {msg.type === 'system' ? (
                <span className="text-xs text-muted-foreground bg-muted px-2 py-1 rounded">
                  {msg.message}
                </span>
              ) : (
                <>
                  <div className="flex items-baseline gap-2">
                    <span className="text-xs font-medium text-muted-foreground">
                      {msg.username}
                    </span>
                    <span className="text-xs text-muted-foreground">
                      {formatTime(msg.timestamp)}
                    </span>
                  </div>
                  <div
                    className={`max-w-[80%] px-3 py-2 rounded-lg text-sm ${
                      msg.userId === currentUser?._id
                        ? 'bg-primary text-primary-foreground'
                        : 'bg-muted'
                    }`}
                  >
                    {msg.message}
                  </div>
                </>
              )}
            </div>
          ))}
        </div>
      </ScrollArea>

      <form onSubmit={handleSendMessage} className="p-3 border-t flex gap-2">
        <Input
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          placeholder="Type a message..."
          maxLength={500}
          className="flex-1"
        />
        <Button type="submit" size="icon" disabled={!inputMessage.trim()}>
          <Send className="h-4 w-4" />
        </Button>
      </form>
    </div>
  );
};

export default ChatPanel;
```
</action>
  <verify>
Check code-arena/src/components/ChatPanel.tsx:
- Imports useSocket and SOCKET_EVENTS
- Listens to room:chat_message events
- Sends messages via socket.emit
- Displays messages with user/time
- System messages styled differently
- Auto-scrolls to bottom
  </verify>
  <done>
- ChatPanel component created
- Uses socket for sending/receiving messages
- Message history loaded on mount
- Auto-scroll to new messages
- System vs user message styling
  </done>
</task>

<task type="auto">
  <name>Task 4: Create PlayerList component</name>
  <files>
    code-arena/src/components/PlayerList.tsx
  </files>
  <action>
Create `code-arena/src/components/PlayerList.tsx`:

```typescript
import React from 'react';
import { useSocket, SOCKET_EVENTS } from '@/contexts/SocketContext';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Crown, CheckCircle2, Circle } from 'lucide-react';

interface Player {
  userId: string;
  username: string;
  isReady: boolean;
  joinedAt: string;
  rating?: number;
}

interface PlayerListProps {
  roomId: string;
  players: Player[];
  hostId: string;
  currentUserId: string | null;
  status: string;
}

export const PlayerList: React.FC<PlayerListProps> = ({
  roomId,
  players,
  hostId,
  currentUserId,
  status
}) => {
  const { socket } = useSocket();
  const isHost = currentUserId === hostId;
  const currentPlayer = players.find(p => p.userId === currentUserId);
  const isReady = currentPlayer?.isReady || false;
  const allReady = players.length >= 2 && players.every(p => p.isReady);

  const handleReadyToggle = () => {
    if (!socket || status !== 'waiting') return;

    socket.emit(SOCKET_EVENTS.ROOM.PLAYER_READY, {
      roomId,
      isReady: !isReady
    }, (response: any) => {
      if (!response.success) {
        console.error('Failed to toggle ready:', response.error);
      }
    });
  };

  const handleStartMatch = () => {
    if (!socket || !isHost || status !== 'waiting') return;

    socket.emit(SOCKET_EVENTS.MATCH.START, { roomId }, (response: any) => {
      if (!response.success) {
        console.error('Failed to start match:', response.error);
      }
    });
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold">
          Players ({players.length})
        </h3>
        {status === 'waiting' && (
          <div className="flex gap-2">
            <Button
              variant={isReady ? "default" : "outline"}
              size="sm"
              onClick={handleReadyToggle}
              disabled={!currentPlayer}
            >
              {isReady ? (
                <>
                  <CheckCircle2 className="h-4 w-4 mr-1" />
                  Ready
                </>
              ) : (
                <>
                  <Circle className="h-4 w-4 mr-1" />
                  Not Ready
                </>
              )}
            </Button>

            {isHost && (
              <Button
                size="sm"
                onClick={handleStartMatch}
                disabled={!allReady}
              >
                Start Match
              </Button>
            )}
          </div>
        )}
      </div>

      <div className="space-y-2">
        {players.map((player) => (
          <div
            key={player.userId}
            className={`flex items-center justify-between p-3 rounded-lg border ${
              player.userId === currentUserId ? 'bg-primary/5 border-primary/20' : 'bg-card'
            }`}
          >
            <div className="flex items-center gap-3">
              <div className="flex items-center gap-2">
                {player.userId === hostId && (
                  <Crown className="h-4 w-4 text-yellow-500" />
                )}
                <span className="font-medium">{player.username}</span>
              </div>
              {player.rating && (
                <Badge variant="secondary" className="text-xs">
                  {player.rating} XP
                </Badge>
              )}
            </div>

            <div className="flex items-center gap-2">
              {player.isReady ? (
                <Badge variant="default" className="bg-green-500">
                  <CheckCircle2 className="h-3 w-3 mr-1" />
                  Ready
                </Badge>
              ) : (
                <Badge variant="secondary">
                  <Circle className="h-3 w-3 mr-1" />
                  Waiting
                </Badge>
              )}
            </div>
          </div>
        ))}
      </div>

      {status === 'waiting' && isHost && !allReady && (
        <p className="text-sm text-muted-foreground text-center">
          All players must be ready to start
        </p>
      )}
    </div>
  );
};

export default PlayerList;
```
</action>
  <verify>
Check code-arena/src/components/PlayerList.tsx:
- Imports useSocket and SOCKET_EVENTS
- Displays player list with ready status
- Shows host with crown icon
- Ready toggle button for current player
- Start match button for host (disabled until all ready)
- Uses socket.emit for ready toggle and match start
  </verify>
  <done>
- PlayerList component created
- Shows players with ready status badges
- Host indicated with crown icon
- Ready toggle sends socket event
- Start match button for host with validation
  </done>
</task>

<task type="auto">
  <name>Task 5: Update Room.tsx with socket integration</name>
  <files>
    code-arena/src/pages/app/Room.tsx
  </files>
  <action>
Update `code-arena/src/pages/app/Room.tsx` to use socket events:

Key changes:

1. Add imports:
```typescript
import { useSocket, SOCKET_EVENTS } from '@/contexts/SocketContext';
import { ChatPanel } from '@/components/ChatPanel';
import { PlayerList } from '@/components/PlayerList';
```

2. In the component, replace polling with socket:
```typescript
const { socket, isConnected } = useSocket();
const [room, setRoom] = useState<any>(null);
const [players, setPlayers] = useState<any[]>([]);

// Join room and listen for updates
useEffect(() => {
  if (!socket || !isConnected || !id) return;

  // Join room
  socket.emit(SOCKET_EVENTS.ROOM.JOIN, { roomId: id }, (response: any) => {
    if (response.success) {
      setRoom(response.data.room);
      setPlayers(response.data.room.players);
    } else {
      toast.error(response.error || 'Failed to join room');
      navigate('/app/lobby');
    }
  });

  // Listen for player joins
  socket.on(SOCKET_EVENTS.ROOM.PLAYER_JOINED, (data: any) => {
    toast.info(`${data.player.username} joined the room`);
    // Refresh room data
    socket.emit(SOCKET_EVENTS.ROOM.JOIN, { roomId: id }, (response: any) => {
      if (response.success) {
        setPlayers(response.data.room.players);
      }
    });
  });

  // Listen for player leaves
  socket.on(SOCKET_EVENTS.ROOM.PLAYER_LEFT, (data: any) => {
    toast.info(`${data.player.username} left the room`);
    setPlayers(prev => prev.filter(p => p.userId !== data.player.userId));
  });

  // Listen for ready status changes
  socket.on(SOCKET_EVENTS.ROOM.PLAYER_READY, (data: any) => {
    setPlayers(prev => prev.map(p => 
      p.userId === data.player.userId 
        ? { ...p, isReady: data.player.isReady }
        : p
    ));
  });

  // Listen for match start
  socket.on(SOCKET_EVENTS.MATCH.STARTED, (data: any) => {
    toast.success('Match is starting!');
    // Update room status
    setRoom(prev => prev ? { ...prev, status: 'playing' } : null);
  });

  return () => {
    socket.emit(SOCKET_EVENTS.ROOM.LEAVE, { roomId: id });
    socket.off(SOCKET_EVENTS.ROOM.PLAYER_JOINED);
    socket.off(SOCKET_EVENTS.ROOM.PLAYER_LEFT);
    socket.off(SOCKET_EVENTS.ROOM.PLAYER_READY);
    socket.off(SOCKET_EVENTS.MATCH.STARTED);
  };
}, [socket, isConnected, id]);
```

3. Replace leave room button handler:
```typescript
const handleLeaveRoom = () => {
  if (!socket) return;
  
  socket.emit(SOCKET_EVENTS.ROOM.LEAVE, { roomId: id }, (response: any) => {
    if (response.success) {
      toast.success('Left room');
      navigate('/app/lobby');
    } else {
      toast.error(response.error || 'Failed to leave room');
    }
  });
};
```

4. Render ChatPanel and PlayerList components:
```tsx
<div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
  {/* Main content */}
  <div className="lg:col-span-2 space-y-6">
    {/* ... existing room info ... */}
  </div>

  {/* Sidebar */}
  <div className="space-y-6">
    <PlayerList
      roomId={id}
      players={players}
      hostId={room?.createdBy}
      currentUserId={user?._id}
      status={room?.status}
    />
    
    <div className="h-[400px]">
      <ChatPanel roomId={id} currentUser={user} />
    </div>
  </div>
</div>
```
</action>
  <verify>
Check code-arena/src/pages/app/Room.tsx:
- Imports useSocket and SOCKET_EVENTS
- Joins room via socket on mount
- Listens to player:joined, player:left, player:ready events
- Listens to match:started event
- Uses ChatPanel and PlayerList components
- Leave room uses socket.emit
- Cleanup on unmount (room:leave)
  </verify>
  <done>
- Room.tsx uses socket for all room operations
- Joins room on mount via socket
- Listens for player updates in real-time
- Renders ChatPanel and PlayerList
- Handles match start event
- Cleanup on unmount
  </done>
</task>

</tasks>

<verification>
1. Backend chat handlers respond to room:chat_message
2. Chat messages broadcast to all room members
3. PlayerList shows real-time ready status
4. Room page auto-updates when players join/leave
5. Chat history persists during room session
6. Host can start match when all players ready
</verification>

<success_criteria>
- ChatPanel sends/receives messages via socket
- PlayerList displays real-time ready status
- Room page updates instantly when players join/leave
- Match start works with socket event
- Message history loaded on chat mount
- All players see same state simultaneously
</success_criteria>

<output>
After completion, create `.planning/phases/02-realtime/02-03-SUMMARY.md`
</output>
